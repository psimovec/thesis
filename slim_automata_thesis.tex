\documentclass[
	digital,
nolof, nolot
]{fithesis3}

\usepackage{paratype}
\def\textrussian#1{{\usefont{T2A}{PTSerif-TLF}{m}{rm}#1}}

\thesissetup{
	date        = \the\year/\the\month/\the\day,
	university  = mu,
	faculty     = fi,
	type        = bc,
	author      = Pavel Šimovec,
	gender      = m,
	advisor     = {doc. RNDr. Jan Strejček, Ph.D.},
	title       = {Transformation of Nondeterministic Büchi Automata to Slim Automata},
	TeXtitle    = {Transformation of Nondeterministic Büchi Automata to Slim Automata},
	keywords    = {slim automata, Büchi Automata, GFM-automata, Seminator},
	TeXkeywords = {slim automata, Büchi Automata, GFM-automata, Seminator},
	abstract    = {%
		The thesis describes emph{slim Büchi good for Markov decision processes automata} construction and extends it for \emph{generalized Büchi Automata}. The construction is implemented in a tool called \emph{Seminator}. Slim automata constructed by Seminator are compared to other automata produced by different tools. The tools are compared by number of states, construction time and learning speed when used for reinforcement learning in \emph{Mungojerrie} tool.
	},
	thanks      = {%
		I would like to thank František Blahoudek for bringing up the topic. I would also like to thank František Blahoudek and Jan Strejček for help with writing the thesis.
	},
	bib         = {exampl.bib},
	%% Uncomment the following line (by removing the %% at the
	%% beginning) and replace `assignment.pdf` with the filename
	%% of your scanned thesis assignment.
	%%    assignment         = assignment.pdf,
}

%%\usepackage{amsmath}


\usepackage{makeidx}      %% The `makeidx` package contains
\makeindex                %% helper commands for index typesetting.
%% These additional packages are used within the document:
\usepackage{paralist} %% Compact list environments
\usepackage{amsmath}  %% Mathematics
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{url}      %% Hyperlinks
\usepackage{markdown} %% Lightweight markup
\usepackage{tabularx} %% Tables
\usepackage{tabu}
\usepackage{booktabs}
\usepackage{listings} %% Source code highlighting
\usepackage{emoji}
\usepackage{cancel}
\usepackage{hhline}
\usepackage{listings}

\usepackage{tikz}
\usepackage{pgfplots}
\usetikzlibrary{myautomata}
\input{commands.tex}

\lstset{
	basicstyle      = \ttfamily,
	identifierstyle = \color{black},
	keywordstyle    = \color{blue},
	keywordstyle    = {[2]\color{cyan}},
	keywordstyle    = {[3]\color{olive}},
	stringstyle     = \color{teal},
	commentstyle    = \itshape\color{magenta},
	breaklines      = true,
}
\usepackage{floatrow} %% Putting captions above tables
\floatsetup[table]{capposition=top}

%% Calligraphy
\newcommand{\cA}{\mathcal{A}}
\newcommand{\cD}{\mathcal{D}}
\newcommand{\cN}{\mathcal{N}}
\newcommand{\cS}{\mathcal{S}}
\newcommand{\cT}{\mathcal{T}}

\newcommand{\lA}{L(\cA)}
\newcommand{\lD}{L(\cD)}
\newcommand{\lS}{L(\cS)}

%\newcommand{\eqdef}{\overset{\mathrm{def}}{=\joinrel=}}
\newcommand{\eqdef}{\overset{def}{=}}

\newcommand{\flushed}{\text{\emoji{flushed}}}
\newcommand{\hell}{\text{\emoji{fire}}}
\newcommand{\heaven}{\text{\emoji{innocent}}}

\newcommand{\hlineny}{\hline}

\begin{document}
	\chapter{Introduction}
	Büchi automaton is a finite machine over infinite words. It has been a topic of research for almost 60 years.
	There were discovered various kinds of similar machines with different properties and use cases.
	Non-deterministic Büchi automata in general are not well suitable for model checking or reinforcement learning, but we can construct non-deterministic Büchi automata with a special property -- good for Markov decision processes (GFM)  \cite{hlavni}, that makes the automata suitable. We will focus on slim automata \cite{hlavni}.
	Slim automata are specially constructed Büchi automata. This kind of automaton was defined by its construction and is good for MDP \cite{hlavni}. We implement the proposed algorithm and its second variant that we call weak [source private conversation]. We introduce the algorithm for generalized Büchi automata. Then we evaluate resulting size of automata and we compare it with different tool to create slim automata and with other kinds of automata. In the end we investigate impact of slim automata from Seminator on reinforcement against GFM automata created by other tools.
	
	Preliminaries chapter defines Büchi automaton and generalized Büchi automaton. Next chapter defines breakpoint automaton and slim automaton as described in our main source \cite{hlavni} and the weak variant. In fourth chapter we extend the algorithm to generalized Büchi automata. Fifth chapter describes implementation of mentioned slim automata inside Seminator \cite{Klokočka2017thesis}\cite{seminator}\cite{seminator2} tool. In sixth chapter we compare resulting automata size (number of states). First we compare the size internally among implemented options. Then we compare it with ePMC \cite{epmc} - another tool implementing slim automata. We finish the chapter by comparisons with different kinds of automata. In the last chapter we use our automata in benchmarks of reinforcement learning tool Mungojerrie\cite{mungojerrie} and we compare learning speed on it with original automata in provided benchmarks with original benchmark automata and 2 types of automata internally supported by Mungojerrie (slim automata by ePMC and Limit-deterministic Büchi automata by ltl2ldba \cite{ltl2ldba}).
	
	

	\chapter{Preliminaries}
		This chapter defines a Büchi automaton and a generalized Büchi automaton. 
		
		
		An \emph{alphabet} $\Sigma$  is a finite set of \emph{letters}, an \emph{$\omega$-word} $w \in \Sigma^\omega$ is an infinite sequence of letters, and an \emph{$\omega$-language} $L \subseteq \Sigma^\omega$ is a set of $\omega$-words.
		\section{Büchi Automaton} \label{section:tba}
			A Büchi automaton is a theoretical finite-state machine used to define $\omega$-languages. It decides which infinite words ($\omega$-words) belong to its language.
			
			A \emph{transition-based Büchi automaton (TBA)} is a tuple $\cA\eqdef(\Sigma, Q, q_i, \Delta, \Gamma)$, where 
			\begin{itemize}
				\item $\Sigma$ is a non-empty finite \emph{alphabet},
				\item $Q$ is a non-empty finite set of \emph{states},
				\item $q_i \in Q$ is the initial state of $\cA$.
				\item $\Delta \subseteq Q \times \Sigma \times Q$ is a set of \emph{transitions}. 
				\item $\Gamma \subseteq \Delta$ is a set of \emph{accepting transitions}.
			\end{itemize}
			 Intuitivelly, a transition $(s, a, t)$  directionally connects the states $s$ and $t$ with the letter $a$.
			 
			 By convention, we use capital greek letters to denote sets of transitions. For convenience, we also define for each set of transitions $\Delta$ a function $\delta$ (denoted by the corresponding small greek letter). 
			 
			A \emph{run} $r$ of $\cA$ over an $\omega$-word $w=w_0w_1w_2\ldots$ is an infinite sequence of transitions
			$r\eqdef t_0t_1\ldots\in\Delta^\omega$, where $t_k=(q_k, w_k,q_{i+1})$,
			 such that $q_0=q_i$.
			A run of $\cA$ is \emph{accepting} if and only if it contains infinitely many accepting transitions from $\Gamma$.

			Finally, we define the \emph{language} $\lA \subseteq \Sigma^\omega$ recognized by the automaton $\cA$. An $\omega$-word $w \in \Sigma^\omega$ belongs to $\lA$ if and only if there exists an accepting run of $\cA$ over the word $w$. 
			
			
		\section{Generalized Büchi Automaton}
		A \emph{transition-based Generalized Büchi automaton} (TGBA) is a tuple $\cA\eqdef(\Sigma, Q, q_i, \Delta, G)$, where $G \subseteq 2^\Delta$ contains sets of accepting conditions and the rest is defined as for TBA. A run of $\cA$ is \emph{accepting} iff it contains infinitely many accepting transitions \emph{for each} $\Gamma \in G$. TBA can be seen as a special case of TGBA with $|G|=1$.
		
		
			
			
			
			\chapter{Slim Automata Construction}\label{section:slim}
			
			%%todle mozna trochu jinak v (ne dalsi ale) teto sekci
			%%We are going to define a few more transitions on top of breakpoint construction which allow us to construct slim automata that decide exactly the class of <GFM languages> spatny pojem. jsou to omega regularni
			
			%Breakpoint automata constructed as presented in the previous section are not always equivalent to the input automaton, but are deterministic. Slim automata are equivalent to do not hold the deterministic property, however they are GFM\footnote{Good for Markov decision processes [+zdroj]}
			
			
			
			
			
			
			
			
			This chapter defines \emph{slim Büchi automaton} (slim automaton) in 2 variants - \emph{strong} and \emph{weak}. Slim automaton is defined through its construction, which is based on breakpoint construction. 
			
			\section{Breakpoint Automaton} \label{section:bp}
			
			 BP automata are constructed from BA and are deterministic, but their language is only a subset of the language from original BA. 
			
			\paragraph{Construction}
			Let us fix a Büchi Automaton $\cA\eqdef(\Sigma, Q, q_i, \Delta, \Gamma)$. 
			
			%%We want to construct a deterministic automaton $\cD$ such that $\lD\subseteq \lA$ 
			We start with some notation. By $3^Q$ we denote the set $\{(S,S') \mid S'\subsetneq S \subseteq Q\}$ and
			by $3^Q_+$ we denote $\{(S,S') \mid S'\subseteq S \subseteq Q\}$.
			
			%%We define the notation for the transitions and accepting transitions as $\delta,\gamma:2^Q \times \Sigma \rightarrow 2^Q$ with
			
			For convenience we introduce functions by sets of transitions, we define the function $\delta \colon 2^Q \times \Sigma \rightarrow 2^Q$ as 	
			$\delta\colon (S,a)\eqdef\{q'\in Q \mid  (q,a,q') \in \Delta \land q \in S\}$.
			%%\exists q \in S.(q,a,q') \in \Delta\}$.
			We define $\gamma:2^Q  \times \Sigma \rightarrow 2^Q$ analogously from $\Gamma$ as $\gamma\colon (S,a)\eqdef\{q'\in Q \mid  (q,a,q') \in \Gamma \land q \in S\}$.
			
			%%$\gamma: (S,a)\eqdef\{q'\in Q \mid \exists q \in S.(q,a,q') \in \Gamma\}$
			
			With $\delta$ and $\gamma$, we define the raw breakpoint transition
			$\rho_\Gamma \colon 3^Q \times \Sigma \rightarrow 3^Q_+$ as
			\[\rho_\Gamma((S, S'), a) \eqdef(\delta(S, a), \delta(S',a)\cup \gamma(S, a))\]
			The first set follows the set of reachable states in the first set and the states that are reachable while passing at least one of the accepting transitions in the second set.
			The transitions of the breakpoint automaton $\cD$ follow $\rho$ with an exception: they reset the second set to the empty set when it equals the first; the resetting transitions are accepting.
			Formally, the breakpoint automaton $\cD$ is $ \eqdef (\Sigma, 3^Q, (q_i, \emptyset), \Delta_D, \Gamma_D)$ where $\Delta_D$ and $\Gamma_D$ are defined as follows. 
			
			\begin{enumerate}
				\item $((S, S'), a, (R, R')) \in \Delta_D$ if $\rho_\Gamma((S,S'),a)=(R,R')$ where $R' \subsetneq R$
				\item $((S, S'), a, (R, \emptyset)) \in \Delta_D$ and $((S, S'), a, (R, \emptyset)) \in \Gamma_D$ if $\rho_\Gamma((S,S'),a)=(R,R)$ 
				\item No other transitions are in $\Delta_D$ and $\Gamma_D$
			\end{enumerate}
			
			%%Breakpoint automata recognize/describe/represent subset of original language 
			Figure \ref{fig:bp:non-equivalent} shows application of this construction. The example demonstrates that $\lD \subseteq \lA$ as the construction did not generate any accepting transition. Therefore original $\lA=\{a^\omega\}$, but $\lD$ is empty. 
			
			
			
			\begin{figure}[ht]
				\begin{center}
					\input{bp.tikz}
					
				\end{center}
				\caption{A Büchi Automaton $\cA$ (left) and a breakpoint automaton $\cD$ for $\cA$ (right). Inspired by \cite[Figure~7.3]{Blahoudek2018thesis}}
				\label{fig:bp:non-equivalent}
			\end{figure}
		
			\section{Slim automata}
			Slim automata are BP automata enriched with additional transitions. As a result they are non-deterministic, Good for Markov decision processes \cite{hlavni} and equivalent to the input automaton.	
			In this section we define \emph{Breakpoint automaton} and transitions for \emph{strong slim} ($\gamma_{p}$) and \emph{weak slim} ($\gamma_{p}$) automata,
			 $\gamma_w, \gamma_p:3^Q \times \Sigma \rightarrow 3^Q$, that promote the second set of a breakpoint construction to the first set as follows. 
			
			\begin{enumerate}
				\item if $\delta_S(S',a) = \gamma_S(S, a) = \emptyset$, then $\gamma_{p}((S,S'), a)$ and $\gamma_{w}((S,S'), a)$ are undefined, and
				\item otherwise
				$\gamma_{p}:((S,S'),a)=(\delta(S',a)\cup\gamma(S, a),\emptyset)$ and $\gamma_{w}:((S,S'),a)=(\delta(S',a),\emptyset)$
			\end{enumerate}
			
			
			$\cS\eqdef(\Sigma, 3^Q, (q_i,\emptyset), \Delta_S ,\Gamma_S)$ is slim, when
			$\Delta_S=\Delta_D \cup \Gamma_p$ is set of transitions generated by $\delta_D$ and $\gamma_p$, and
			$\Gamma_S=\Gamma_D \cup \Gamma_p$ is set of accepting transitions, that is generated by $\gamma_D$ and $\gamma_p$. $\lS = \lA$. The equivalence was proven in \cite{hlavni}.
			
			Alternatively, similarly defined using $\gamma_w$ instead of $\gamma_{p}$, automaton $\mathcal{W}\eqdef(\Sigma, 3^Q, (q_i,\emptyset), \Delta_W, \Gamma_W)$ is slim  when
			$\Delta_W=\Delta_D \cup \Gamma_w$ is set of transitions generated by $\delta_D$ and $\gamma_w$, and
			$\Gamma_W=\Gamma_D \cup \Gamma_w$ is set of accepting transitions, that is generated by $\gamma_D$ and $\gamma_w$. $\lS = \lA$ and $\lS=\lA$. (proof would go similarly like the one for strong slim)
			
			\begin{figure}[ht]
				\begin{center}
				\input{slim.tikz}
				\end{center}
				\caption{Slim automaton (right) and the original Buchi Automaton from Figure \ref{fig:bp:non-equivalent}(left)}
				\label{fig:slim:equivalent}
			\end{figure}

			
			\chapter{Slim Automaton Construction Generalized to TGBA} \label{section:gslim}
			In this chapter, we discuss slim automata equivalent to a TGBA $\cT\eqdef(\Sigma, Q, q_i, \Delta, G)$.
			One possibility is to \emph{degeneralize} $\cT$ and to use previously mentioned algorithm in section 2.3.
			In the rest of this chapter we introduce a direct construction of slim TGBA equivalent to $\cT$.
			\paragraph{Extended slim construction}
			(We will simulate the original automaton by checking its accepting conditions on by one. In the original automaton have to go through an accepting transition of each accepting condition $g \in G=\{G_0, G_1, \ldots, G_k\}$ infinitely many times. In new automaton we have just one accepting condition and a layer for each original accepting condition. Going through original accepting transitions of layer that we are looking up promotes us to another layer. From the last layer we get back to first layer. Only the transitions that move us layer up are accepting. As we check all accepting conditions of the original automaton, the new automaton will be equivalent to the original one.)
			
			We need to make sure we go infinitely many times trough each accepting subset $g \in G$.
			To achieve this, we will go through each subset one by one, using original algorithm. We will keep track of $levels\eqdef\{0,1,\ldots,|G|-1\}$ in the names of states. Let $|G|$ be number of $levels$ and $i \in \mathbb{N}, i<|G|$ the current level.
			At each level $i$, we look at $i$th subset of $G$. We use same steps as in classic breakpoint construction, but on each accepting transition the new state will be leveled up to $(i+1)\bmod|G|$, otherwise the target state has the same level. Our new automaton simulates $\cT$, as it accepts a word if it cycles through all levels. If $|G|=0$, we return a trivially accepting automaton
			
			We can use the core of previous construction and just to extend it with levels.
			%$3^Q_i :=\{(S,S',i)|S'\subset S \subseteq Q, i \in N, i<|G|\}$ and
			%$3^Q_{i+}:=\{(S,S',i)|S'\subseteq S \subseteq Q, i \in N, i<|G|\}$.
	
			
			Let $(S,S')\in 3^Q$ and let $i \in levels$, by $P$ we denote a state $P=(S,S',i)$.
			%$\delta: (S,a)\rightarrow\{q'\in Q | \exists q \in S.(q,a,q') \in \Delta\}$ and
			
			%%$\gamma_{iS}: (S,a)\rightarrow\{q'\in Q | \exists q \in S.(q,a,q') \in G_i\}$
			We define $\gamma_i$ from $\Gamma_i$ for all $i \in levels$ in the same way we did for $\gamma$ from $\Gamma$ and it allows us to easily define the raw generalized breakpoint transitions
			$\rho_{\Gamma_{i}}\colon$ similarly as $\rho_\Gamma$ using $\gamma_i$ instead of $\gamma$.
			
			Let $up(x)=(x+1)\bmod|G|$.
			
			The generalized breakpoint automaton $\cD=(\Sigma, 3^Q\times\cN, ({q_i},\emptyset, 0),\delta_B,\gamma_B)$ is defined such that, when $\delta_R\colon(P, a) \rightarrow (R, R', j)$, then there are three cases:
			
			
			
			\begin{enumerate}
				\item if $R=\emptyset$ , then $\delta_B(P,a)$ is undefined,
				\item else, if $R \neq R'$, then $\delta_B(P,a) = (R,R',i)$ is a non-accepting transition,
				\item otherwise $\gamma_B(P, a) = \delta_B(P,a) = (R, \emptyset, up(i))$.
			\end{enumerate}
		
		
			%%	$\gamma_{p}: P \times \Sigma \rightarrow P$
			\begin{enumerate}
				\item if $\delta(S',a)=\gamma_{i}(S, a)=\emptyset$, then $ \gamma_{p}(P,a)$ is undefined, and
				\item otherwise $\gamma_p \colon (P,a) = (\delta(S',a)\cup \gamma_{i}(S, a), \emptyset, up(i))$. (Alternatively, for a weak slim automaton we do not include transitions $\gamma_{i}(S, a)$)
			\end{enumerate}
			$\cS\eqdef(\Sigma, P, (q_i,\emptyset,0), \Delta_p,\Gamma_p))$ is slim, when $\Delta_p$ is set of transitions generated by $\delta_b$ and $\gamma_p$, and $\Gamma_p$ is set of accepting transitions, that is generated by $\gamma_b$ and $\gamma_p$. We construct weak slim automata 
			
						
			\begin{figure}[ht]
				\begin{center}
					\input{tgba.tikz}
					
				\end{center}
				\caption{The original TGBA (top) and slim automaton with colored states emphasizing different levels (bottom)  }
				\label{fig:slim:gg}
			\end{figure}
			

			
	\chapter{Implementation}
		I have implemented the generalized construction of slim automata in both weak and strong version  (\ref{section:slim}) (\ref{section:gslim}). I have also added option to create breakpoint automata (\ref{section:bp})(2.3).
		
		\section{Technologies/Tools}
		The implementation is inside seminator which is implemented in C++17 builds on Spot library. %\cite{DBLP:conf/mascots/Duret-LutzP04}.
		\subsection{Seminator} 
		Seminator is a Linux command-line tool which can be run with the \texttt{seminator} command. The tool transforms transition-based generalized Büchi automata (TGBAs) into equivalent semi-deterministic automata. \cite{Klokočka2017thesis}\cite{seminator}\cite{seminator2}
		
		
		
		The tool expects the input automaton in the Hanoi Omega-Automata(HOA) format \cite{DBLP:conf/cav/BabiakBDKKM0S15} on the standard input stream, but it can also read the input automaton from a file.
		
	\subsection{Spot}
	Spot is a C++ library with Python bindings and an assortment of command-line tools designed to manipulate LTL and $\omega$-automata in batch. \cite{spot2}
	
	Relevant spot tools:
	\paragraph{ltl2tgba} The ltl2tgba tool translates LTL or PSL formulas into different types of automata. \cite{ltl2tgba}
	\paragraph{autfilt} The autfilt tool can filter, transform, and convert a stream of automata. \cite{autfilt}
	\paragraph{ltlcross} ltlcross is a tool for cross-comparing the output of LTL-to-automata translators. \cite{ltlcross}
		\section{Create Slim Automata Using Seminator}
		By default, seminator creates sDBA. To create a slim automaton we need to add -{}-slim option. 
		\paragraph{Options} By default, -{}-slim tries all reasonable combinations of options, optimizes the output and chooses an automaton with the smallest number of states.
		
		\paragraph{Example 1}
		Transform automaton.hoa to a slim automaton.

		\begin{lstlisting}[language=bash]
$./seminator --slim -f automaton.hoa
		\end{lstlisting}
		
		There are several options to specify how we construct the automata.
		
		For example \texttt{seminator -{}-slim -{}-strong -{}-optimizations=0 -{}-via-tgba} generates output according to algorithm in 2.5. (Using \texttt{-{}-via-tba} converts input to tba first) With automaton
		
		
		\paragraph{Example 2}
		Transform automaton.hoa to unoptimized strong slim automaton
		\begin{lstlisting}[language=bash]
$./seminator --slim --strong --via-tgba --postprocess=0 -f automaton.hoa
		\end{lstlisting}
		
		 
		
		\texttt{-{}-slim }to generate slim automaton
		
		\texttt{-{}-weak} use only weak slim algorithm
		
		\texttt{-{}-strong} use only strong slim algorithm
		
		Neither weak or strong option specified - try both options  and choose the one with smaller automaton.
		
		\texttt{-{}-via-tba} transform input automaton to tba (\ref{section:tba}) first
		
		\texttt{-{}-via-tgba} does not modify input automaton to tba.
		
		Neither \texttt{-{}-via-tba} nor \texttt{-{}-via-tgba}: try both options, choose the smallest automaton.
		
		Postprocess optimalizations are enabled by default.
		
		
	\section{Implementation of Slim Automata inside Seminator}
	I have implemented the generalized slim construction and its options mentioned in previous section 3.2. Furthermore, I have added an option to create breakpoint automata.
	
	There already was basis for breakpoint construction in seminator, inside class \texttt{bp\_twa}.
	As we can see in sections \ref{section:bp} and \ref{section:slim}, slim automata construction builds on breakpoint automata construction.
	
	That allows us to simply extend the \texttt{bp\_twa} class.
	We create class \texttt{slim} that inherits from \texttt{bp\_twa}.
	In the \texttt{slim} class we build breakpoint automaton using \texttt{compute\_successors} method.
	Then we extend the method by adding accepting transitions $\gamma_p$, respectively $\gamma_w$ according to section 2.4, whenever we receive \texttt{-{}-slim} option.
	
	Then we extend main function to recognize our desired CLI options.
	
	As seminator didn't offer a command line option to create a breakpoint automaton, I have added the option \texttt{-{}-bp} for comparison.
	
	
	
	\section{Testing and Verification}
	Implemented tests are basic, only language equivalence is checked.
	ltlcross and ltl2tgba tools are used. The tests use random LTL formulas that were already generated, the LTL formulas are transformed into automata in HOA format by ltl2tgba.
	Then the tool ltlcross cross-compares the automaton with \emph{seminator -{}-slim} with all supported additional parameters.
	
	Only \texttt{seminator -{}-slim -{}-strong -{}-via-tba -{}-optimizations=0} is proved, as it follows construction from \cite{hlavni} which is proved.
	
	
	\section{fuj - How to Install Seminator}
	(jeste nevim kde tuto sekci dat, jestli ma mit tento nazev, co vsechno tady bude treba dat... no a jeste ro pak upravim podle toho jak to bude odevzdane v zipu)
	
	To install the tool we need install spot and to run 
	
	\begin{lstlisting}[language=bash]
autoreconf -i && ./configure && make.
	\end{lstlisting}
	\section{Future of Implementation}
	Implementation:
	python bindings, optimizations of slim construction (especially from TGBA)
	
	
	
	tests/verification:
	There should be another kind of tests - to check if our slim automata simulate the input automata (so the GFM property is not broken)
	
	Subject of following research, that is out of scope of this thesis, could be to verify if spot optimizations do not break the simulation property. 
	
	\chapter{Evaluation of automaton size}
	Evaluation part builds on seminator-evaluation. We compare amount of states of output automata on 2 datasets. First dataset are 20 literature formulas, second dataset is 500 automata that were randomly generated. We use 120s timeout for each tool. First section starts by internal comparison of slim automata created by Seminator. Second section compares these automata against ePMC, which is another tool producing slim automata. Third section compares slim automata against ldba and semi-deterministic automata. Ldba automata are produced by ltl2ldba \cite{ltl2ldba}, and semi-deterministic automata are produced by Seminator. Let us note, that from mentioned types of automata, only semi-deterministic automata do not promise good for Markov decision processes property.
	
	\section{Slim automata produced by Seminator}
	In this section we compare automaton size generated by seminator -{}-slim.
	We compare weak against slim and via-tba against via-tgba.
	\subsection{Comparisons among Unoptimized Configurations}
	In this subsection we compare base unoptimized seminator options.
\begin{table}[ht]
	\centering
	\caption{Slim automata on both datasets without any post-processing. Strong slim automata have more states than weak ones, as expected, because strong slim automata add more accepting transitions, which can create new states. }
		\begin{tabular}{ |c||c|c|c|c| } 
			\hline
			seminator&\multicolumn{2}{c|}{weak}&\multicolumn{2}{c|}{strong} \\
			\hline
			literature&size&time(s)&size&time(s)\\
			\hhline{|=====|}
			
			via tba	&	1095	&4	& 1112 	&5\\
			\hline
			via tgba&	1122	&4		&1147	&4\\ 
			\hline
			\hline
			\hline
			seminator&\multicolumn{2}{c|}{weak}&\multicolumn{2}{c|}{strong} \\
			\hhline{|=====|}
			random&size&time(s)&size&time(s)\\
			\hline
			via tba&17567&	59& 18764 &57\\
			\hline
			via tgba&19320&	58& 20789&58\\ 
			\hline
		\end{tabular}
\end{table}
	
	

	
	
	Transforming automata to TBA first yields smaller automata. This might be caused by Spot having well optimized algorithm for degeneralization. Slim algorithm for TGBA proposed in this paper is naive, without any kind of optimizations, and it degeneralizes the automaton during the process.
	
	Using weak slim algorithm creates smaller slim automata than the strong one. 

	\subsection{Post-Optimized}
	In this subsection we post-optimize results using \texttt{autfilt} tool.
	
	GFM automata are closed under simulations \cite[Section~3.1]{hlavni}. We are confident that spot's \texttt{autfilt} does not break the property.
	
	\begin{table}[ht]
		\centering
		\caption{In this table we compare all possible post-optimized combinations of parameters. By default \texttt{seminator --slim} tries all combination, runs optimizations, and then chooses the smallest automaton (best/best). }
		\begin{tabular}{ |c||c|c|c|c|c|c| } 
			\hline
			seminator&\multicolumn{2}{c|}{weak}&\multicolumn{2}{c|}{strong}&\multicolumn{2}{c|}{best} \\
			\hline
			literature&size&time[s]&size&time[s]&size&time[s]\\
			\hhline{|=======|}
			
			via tba&551&219& 370 &185& 370&404\\
			\hline
			via tgba&588&210& 408&174& 402&384\\ 
			\hline
			best&551&429& 370&359& 365&788 \\ 
			\hline
			
			
			\hline
			seminator&\multicolumn{2}{c|}{weak}&\multicolumn{2}{c|}{strong}&\multicolumn{2}{c|}{best} \\
			\hline
			random&size&time[s]&size&time[s]&size&time[s]\\
			\hhline{|=======|}
			via tba&8923&443& 7404 &476& 7219&919\\
			\hline
			via tgba&10130&654& 8500&591& 8247&1245\\ 
			\hline
			best&8751&1097& 7285&1067& 7088&2164 \\ 
			\hline
		\end{tabular}
	\end{table}

	
	From 4 base options; after applying post-optimizations strong slim algorithm surpasses weak one by resulting automaton size, even if it has worse results without the post-optimizations.
	Degeneralizing the automata as a first step still has smaller results.
	From 4 base options, strong slim algorithm via-tba creates smallest automata on average.
	Transforming input automata to tba first creates results which are close to best ones. 
	
	\clearpage
	\subsubsection{Strong against Weak slim automata}
	Let us focus on automaton size differences between weak and strong slim automata.
		\begin{figure}[ht]
			\centering 
			\caption{Scatter plot of strong against weak slim automata, equal values excluded. We can see strong slim automaton is smaller in more cases, but there are also cases where weak slim automaton is smaller.}
		
		\begin{tikzpicture}
			\input{scatter/strong-weak.tikz}
		\end{tikzpicture}
	\end{figure}
	
		{Minimal hits for weak x strong automata}
		\begin{table}[ht]
			\centering
			\caption{Strong slim automata lead in unique minimal hits, but weak slim automata have some unique minimal hits too, so it makes sense to try both options and choose better one. }
			\begin{tabular}{ |c||c|c| } 
				\hline
				literature&unique minimal hits&minimal hits\\
				\hhline{|===|}
				weak&4 & 9\\
				\hline
				strong&11 & 16\\ 
				\hline
				\hline
				random&unique minimal hits&minimal hits\\
				\hhline{|===|}
				weak&68 & 202\\
				\hline
				strong&296 & 430\\ 
				\hline
			\end{tabular}
		\end{table}

		\clearpage
		\subsubsection{Via-tba against via-tgba}
		Let us note that 13/20 formulas from literature and 391/500 formulas from random dataset create automata that are already TBA.
		
		\begin{figure}[ht]
		\caption{Scatter plot via-tba against via-tgba, equal values excluded. Plot density is low, as many of results are the same (majority of the automata were already tba). Via-tba has mostly better results, but there are also examples where via-tgba outputs automaton twice smaller automaton.}
		\begin{tikzpicture}
			\input{scatter/tba-tgba.tikz}
		\end{tikzpicture}
	\end{figure}
		
		 
		\begin{table}[ht]
			
			\centering
			\caption{As was visible on scatter plot, via-tba has better results. Via-tgba has only 9 minimal hits compared to 91 from via-tba.}
			\begin{tabular}{ |c||c|c| } 
				\hline
				literature&unique minimal hits&minimal hits\\
				\hhline{|===|}
				via-tba&7 & 20\\
				\hline
				via-tgba&0 & 13\\ 
				\hline
				\hline
				random&unique minimal hits&minimal hits\\
				\hhline{|===|}
				via-tba&91 & 489\\
				\hline
				via-tgba&9 & 407\\ 
				\hline
			\end{tabular}
		\end{table}
	\clearpage
		\section{Slim Automata Produced Seminator versus ePMC}
		We can create slim automata using different tool called ePMC.
		
		At first we compare best working basic paramaters (parameters that try only 1 option) of each tool to create smallest automata to obtain fair time comparison.
	
	\begin{table}[ht]
		\centering
		\caption{EPMC acc stands for option, that uses accepting transitions whenever possible, it had slightly better results than other ePMC options. }
		\begin{tabular}{ |c||c|c| } 
			\hline
			literature&size&time[s]\\
			\hhline{|===|}
			ePMC acc&650 &178 \\
			\hline
			Seminator tba strong &436 &151 \\
			\hlineny
			\hline
			random&size&time[s]\\
			\hhline{|===|}
			ePMC acc&9643 & 5146\\
			\hline
			Seminator tba strong &7032 &405 \\
			\hlineny
		\end{tabular}
	\end{table}
	\begin{figure}[ht]
		\centering
		\caption{On scatter plot comparing sizes we can see that epmc has some better hits.}
		\begin{tikzpicture}
			\input{scatter/slim-epmc-1-option.tikz}
		\end{tikzpicture}
	\end{figure}
	
	
		The section compares smallest automata of each tool and to see how smaller automata get by combining these tools.
	
\begin{figure}[ht]
	\centering
	\caption{If we compare smallest automata of each tool, Seminator slim has most of the best results and the difference is even bigger than single option comparison. Combining Seminator and ePMC for best automata didn't bring much better results. On random dataset total size of automata from Seminator slim is 7133. If we combine Seminator slim and ePMC, we get total size 7060, which is not that significant difference.}
	\begin{tikzpicture}
		\input{scatter/slim-epmc.tikz}
	\end{tikzpicture}
\end{figure}
Then this section continues with comparison of minimal hits.

\begin{table}[ht]
	\centering
	\caption{By unique minimal hits of these tool we can see that ePMC has 35 unique minimal hits compared to 344 of Seminator. But as we can see from previous scatter plot, the size difference isn't that high.}
	\begin{tabular}{ |c||c|c| } 
		\hline
		literature&unique minimal hits&minimal hits\\
		\hhline{|===|}
		ePMC&1 & 5\\
		\hline
		Seminator &15 & 19\\ 
		\hline
		\hline
		random&unique minimal hits&minimal hits\\
		\hhline{|===|}
		ePMC&35 & 155\\
		\hline
		Seminator &344 & 464\\ 
		\hline
	\end{tabular}
\end{table}
		
	
	
	
		%%\subsection{Comparisons among Unoptimized options}
		%%\subsection{Comparisons among Post-Optimized options}
		
		
		%%\section{via tba/no change}
		%%\subsection{Comparisons among Unoptimized options}
		%%\subsection{Comparisons among Post-Optimized options}

		%\section{Slim automata produced seminator ePMC}
	\clearpage
		\section{Compare with Different Kinds of Automata}
		This section brings size comparison with diffent kinds of automata. It compares slim automata with ltl2ldba \cite{ltl2ldba} and ePMC \cite{epmc}.
		
		\begin{table}[ht]
			\centering
			\caption{Results show that semi-deterministic automata created by Seminator are the smallest on average among the compared tools. Ltl2ldba creates the smallest GFM automata, as semi-deterministic automata do not promise GFM property. }
			\input{tables/basic-tools.tex}
		\end{table}
		
		
		
		Now we compare \texttt{seminator --slim} with other tools using scatter plots.
		\begin{figure}[ht]
			\centering
			\caption{Semi-deterministic automata are consistently smaller or just slightly bigger than slim automata.}
			\begin{tikzpicture}
				\input{scatter/slim-sem_def.tikz}
			\end{tikzpicture}
		\end{figure}
		
		
		\begin{figure}[ht]
			\centering
			\caption{Ltl2ldba creates consistently small automata (smaller than 40 states), however its dominance over slim automata is not that consistent. The plot shows we can create reasonably smaller MDP automata on average using both tools and choosing the smallest automaton. }
		\begin{tikzpicture}
		\input{scatter/slim-ltl2ldba.tikz}
		\end{tikzpicture}
		\end{figure}
	
	\begin{table}[ht]
		\centering
		\caption{This table confirms, that combining Seminator slim and ltl2ldba creates reasonably smaller automata. For literature dataset it even beats semi-deterministic automata from Seminator.}
		\input{tables/basic-tools-mix.tex}
	\end{table}

	\chapter{Mungojerrie Benchmarks}
	This chapter compares seminator's slim automata on reinforcement learning tool Mungojerrie \cite{mungojerrie}.
	
	Experiment uses benchmarks provided with the tool - Examples. The examples are built by various ways, some can be even handcrafted. Using LTL that is provided we create slim automata for comparison on benchmarks, as Mungojerrie can accept LTL and transform it using internally supported tools ltl2ldba and ePMC, or we can provide automaton that is GFM (the property is not checked by Mungojerrie).
	
	TADY ZAKLADNI POPIS JAK FARA MUNGOS
	
	Experiments are searching for lowest necessary amount of episodes needed for reaching probability 1 to hit the goal. Experiments run benchmarks 10 times with pseudo random seeds 0-9. If all runs ends with success, experiment computes median and average of results. A run can fail by timeout (600s) or by not reaching probability 1.
	
	Table~\ref{Table:mungostats}.1 shows that ltl2ldba has unique best results most often, but Seminator slim has some best hits too.
	
	Examples have unclear origins, therefore Table~\ref{Table:mungostatsnoex}.2 shows the results without the Examples. Ltl2ldba still has the best unique results most often, but Seminator gets closer. The table also shows ePMC having higher amount of second best averages and medians than other tools. 
	
	\begin{table}[ht]
		\centering
		\label{Table:mungostats}
		\caption{Results with Examples included}
		\input{mungostats.tex}
	\end{table}
	
	\begin{table}[ht]
		\centering
		\label{Table:mungostatsnoex}
		\caption{Results with Examples excluded shows that ltl2ldba still has the best results most often, but Seminator slim has some best hits too. And ePMC has lots of second best... }
		\input{tables/stats-noexamples.tex}
	\end{table}
	
	\begin{table}[ht]
		\centering
		\label{Table:mungobenchmarks}
		\caption{Table of average episodes needed to reach probability 1.}
		\input{mungobench.tex}
	\end{table}
	
	\begin{figure}[ht]
		\centering
		\label{Cactus:mungoaverage}
		\caption{Sorted values for benchmark's average run for each tool, automaton size on x-axis, benchmarks sorted by automaton size on y-axis.}
		\input{cactuses/average.tikz}
	\end{figure}
	
	\begin{figure}[ht]
		\centering
		\label{Cactus:mungoruns}
		\caption{Sorted values for all of benchmark runs for each tool, automaton size on x-axis, benchmarks runs sorted by automaton size on y-axis.}
	\input{mungocactus.tikz}
	\end{figure}
	
	\chapter{Conclusions}
	
	I have described slim automata with its prerequisities and its weak version.
	I have extended the construction to input TGBA automata.
	I have also implemented the construction of slim automata inside Seminator, which was the main goal.
	Then I have compared automaton size of slim automata and different tools.
	I have ended up with evaluation of performance on Mungojerrie tool.
\end{document}