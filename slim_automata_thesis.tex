\documentclass[
	digital,
nolof, nolot
]{fithesis3}

\usepackage{paratype}
\def\textrussian#1{{\usefont{T2A}{PTSerif-TLF}{m}{rm}#1}}

\thesissetup{
	date        = \the\year/\the\month/\the\day,
	university  = mu,
	faculty     = fi,
	type        = bc,
	author      = Pavel Šimovec,
	gender      = m,
	advisor     = {doc. RNDr. Jan Strejček, Ph.D.},
	title       = {Transformation of Nondeterministic Büchi Automata to Slim Automata},
	TeXtitle    = {Transformation of Nondeterministic Büchi Automata to Slim Automata},
	keywords    = {slim automata, Büchi Automata, GFM-automata, Seminator},
	TeXkeywords = {slim automata, Büchi Automata, GFM-automata, Seminator},
	abstract    = {%
		The thesis describes \emph{slim Büchi good for Markov decision processes automata} construction and extends it for \emph{generalized Büchi Automata}. The construction is implemented in a tool called \emph{Seminator}. Slim automata constructed by Seminator are compared to other automata produced by different tools. The automata are compared by the number of states, construction time, and learning speed when used for reinforcement learning in \emph{Mungojerrie} tool.
	},
	thanks      = {%
		I would like to thank František Blahoudek for bringing up the topic. I would also like to thank František Blahoudek and Jan Strejček for their help with writing the thesis.
	},
	bib         = {exampl.bib},
	%% Uncomment the following line (by removing the %% at the
	%% beginning) and replace `assignment.pdf` with the filename
	%% of your scanned thesis assignment.
	%%    assignment         = assignment.pdf,
}

%%\usepackage{amsmath}


\usepackage{makeidx}      %% The `makeidx` package contains
\makeindex                %% helper commands for index typesetting.
%% These additional packages are used within the document:
\usepackage{paralist} %% Compact list environments
\usepackage{amsmath}  %% Mathematics
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{url}      %% Hyperlinks
\usepackage{markdown} %% Lightweight markup
\usepackage{tabularx} %% Tables
\usepackage{tabu}
\usepackage{booktabs}
\usepackage{listings} %% Source code highlighting
\usepackage{emoji}
\usepackage{cancel}
\usepackage{hhline}
\usepackage{listings}

\usepackage[                % Appendices
toc,page
]{appendix}

\usepackage{tikz}
\usepackage{pgfplots}
\usetikzlibrary{myautomata}
\input{commands.tex}

\lstset{
	basicstyle      = \ttfamily,
	identifierstyle = \color{black},
	keywordstyle    = \color{blue},
	keywordstyle    = {[2]\color{cyan}},
	keywordstyle    = {[3]\color{olive}},
	stringstyle     = \color{teal},
	commentstyle    = \itshape\color{magenta},
	breaklines      = true,
}
\usepackage{floatrow} %% Putting captions above tables
\floatsetup[table]{capposition=top}

%% Calligraphy
\newcommand{\cA}{\mathcal{A}}
\newcommand{\cD}{\mathcal{D}}
\newcommand{\cN}{\mathcal{N}}
\newcommand{\cS}{\mathcal{S}}
\newcommand{\cT}{\mathcal{T}}

\newcommand{\lA}{L(\cA)}
\newcommand{\lD}{L(\cD)}
\newcommand{\lS}{L(\cS)}

%\newcommand{\eqdef}{\overset{\mathrm{def}}{=\joinrel=}}
\newcommand{\eqdef}{\overset{def}{=}}

\newcommand{\flushed}{\text{\emoji{flushed}}}
\newcommand{\hell}{\text{\emoji{fire}}}
\newcommand{\heaven}{\text{\emoji{innocent}}}

\newcommand{\hlineny}{\hline}

\begin{document}
	\chapter{Introduction}
	Büchi automaton is a finite machine over infinite words. It has been a topic of research for almost 60 years.
	There were discovered various kinds of similar machines with different properties and use cases.
	Non-deterministic Büchi automata, in general are not well suitable for model checking or reinforcement learning, but we can construct non-deterministic Büchi automata with a special property -- good for Markov decision processes (GFM)  \cite{hlavni}, that makes the automata suitable. We will focus on slim automata \cite{hlavni}.
	Slim automata are specially constructed Büchi automata. This kind of automaton was defined by its construction and is good for MDP \cite{hlavni}. We implement the proposed algorithm and its second variant that we call weak [source private conversation]. We introduce the algorithm for generalized Büchi automata. Then we evaluate resulting size of automata, and we compare it with a different tool to create slim automata and with other kinds of automata. In the end, we investigate the impact of slim automata from Seminator on reinforcement against GFM automata created by other tools.
	
	The Preliminaries chapter defines Büchi automaton and generalized Büchi automaton.
	The next chapter defines breakpoint automaton and slim automaton as described in our main source \cite{hlavni} and the weak variant.
	In the fourth chapter, we extend the algorithm to generalized Büchi automata.
	Fifth chapter describes implementation of mentioned slim automata inside Seminator \cite{Klokočka2017thesis}\cite{seminator}\cite{seminator2} tool.
	In the sixth chapter, we compare the resulting automata size (number of states). First, we compare the size internally among implemented options. Then we compare it with ePMC \cite{epmc} - another tool implementing slim automata. We finish the chapter by comparing different kinds of automata.
	In the last chapter, we use our automata in benchmarks of reinforcement learning tool Mungojerrie\cite{mungojerrie}, and we compare learning speed on it with original automata in provided benchmarks with original benchmark automata and two types of automata internally supported by Mungojerrie (slim automata by ePMC and Limit-deterministic Büchi automata by ltl2ldba \cite{ltl2ldba}).
	
	

	\chapter{Preliminaries}
		This chapter defines a Büchi automaton and a generalized Büchi automaton. 
		
		
		An \emph{alphabet} $\Sigma$  is a finite set of \emph{letters}, an \emph{$\omega$-word} $w \in \Sigma^\omega$ is an infinite sequence of letters, and an \emph{$\omega$-language} $L \subseteq \Sigma^\omega$ is a set of $\omega$-words.
		\section{Büchi Automaton} \label{section:tba}
			A Büchi automaton is a theoretical finite-state machine used to define $\omega$-languages. It decides which infinite words ($\omega$-words) belong to its language.
			
			A \emph{transition-based Büchi automaton (TBA)} is a tuple $\cA\eqdef(\Sigma, Q, q_i, \Delta, \Gamma)$, where 
			\begin{itemize}
				\item $\Sigma$ is a non-empty finite \emph{alphabet},
				\item $Q$ is a non-empty finite set of \emph{states},
				\item $q_i \in Q$ is the initial state of $\cA$.
				\item $\Delta \subseteq Q \times \Sigma \times Q$ is a set of \emph{transitions}. 
				\item $\Gamma \subseteq \Delta$ is a set of \emph{accepting transitions}.
			\end{itemize}
			 Intuitivelly, a transition $(s, a, t)$  directionally connects the states $s$ and $t$ with the letter $a$.
			 
			 By convention, we use capital greek letters to denote sets of transitions. For convenience, we also define for each set of transitions $\Delta$ a function $\delta$ (denoted by the corresponding small greek letter).  We define the function  	
			 $\delta\colon (q,a)\eqdef\{q'\in Q \mid  (q,a,q') \in \Delta \land q \in Q\}$. $\Delta$ can be defined by $\delta$ when initial state $q_i$ is defined.
			 
			A \emph{run} $r$ of $\cA$ over an $\omega$-word $w=w_0w_1w_2\ldots$ is an infinite sequence of transitions
			$r\eqdef t_0t_1\ldots\in\Delta^\omega$, where $t_k=(q_k, w_k,q_{i+1})$,
			 such that $q_0=q_i$.
			A run of $\cA$ is \emph{accepting} if and only if it contains infinitely many accepting transitions from $\Gamma$.

			Finally, we define the \emph{language} $\lA \subseteq \Sigma^\omega$ recognized by the automaton $\cA$. An $\omega$-word $w \in \Sigma^\omega$ belongs to $\lA$ if and only if there exists an accepting run of $\cA$ over the word $w$. 
			
			
		\section{Generalized Büchi Automaton}
		A \emph{transition-based Generalized Büchi automaton} (TGBA) is a tuple $\cA\eqdef(\Sigma, Q, q_i, \Delta, G)$, where $G \subseteq 2^\Delta$ contains sets of accepting conditions and the rest is defined as for TBA. A run of $\cA$ is \emph{accepting} iff it contains infinitely many accepting transitions \emph{for each} $\Gamma \in G$. TBA can be seen as a special case of TGBA with $|G|=1$.
		
		
			
			
			
	\chapter{Slim Automata Construction}
			
		
			
			
			
			
			
			
			
			This chapter defines \emph{slim Büchi automaton} (slim automaton) in 2 variants - \emph{strong} and \emph{weak}. Slim automaton is defined through its construction, which is based on breakpoint construction. 
			
			\section{Breakpoint Automaton} \label{section:bp}
			
			 BP automata are constructed from BA, but their language is only a subset of the language from the original BA. 
			
			\paragraph{Construction}
			Let us fix a Büchi Automaton $\cA\eqdef(\Sigma, Q, q_i, \Delta, \Gamma)$. 
			
			%%We want to construct a deterministic automaton $\cD$ such that $\lD\subseteq \lA$ 
			We start with some notation. By $3^Q$ we denote the set $\{(S,S') \mid S'\subsetneq S \subseteq Q\}$ and
			by $3^Q_+$ we denote $\{(S,S') \mid S'\subseteq S \subseteq Q\}$.
			
			%%We define the notation for the transitions and accepting transitions as $\delta,\gamma:2^Q \times \Sigma \rightarrow 2^Q$ with
			
			For convenience we introduce functions by sets of transitions, we define the function $\delta \colon 2^Q \times \Sigma \rightarrow 2^Q$ as 	
			$\delta\colon (S,a)\eqdef\{q'\in Q \mid  (q,a,q') \in \Delta \land q \in S\}$.
			%%\exists q \in S.(q,a,q') \in \Delta\}$.
			We define $\gamma:2^Q  \times \Sigma \rightarrow 2^Q$ analogously from $\Gamma$ as $\gamma\colon (S,a)\eqdef\{q'\in Q \mid  (q,a,q') \in \Gamma \land q \in S\}$.
			
			%%$\gamma: (S,a)\eqdef\{q'\in Q \mid \exists q \in S.(q,a,q') \in \Gamma\}$
			
			With $\delta$ and $\gamma$, we define the raw breakpoint transition
			$\rho_\Gamma \colon 3^Q \times \Sigma \rightarrow 3^Q_+$ as
			\[\rho_\Gamma((S, S'), a) \eqdef(\delta(S, a), \delta(S',a)\cup \gamma(S, a))\]
			The first set follows the set of reachable states in the first set and the states that are reachable while passing at least one of the accepting transitions in the second set.
			The transitions of the breakpoint automaton $\cD$ follow $\rho$ with an exception: they reset the second set to the empty set when it equals the first; the resetting transitions are accepting.
			Formally, the breakpoint automaton $\cD$ is $ \eqdef (\Sigma, 3^Q, (q_i, \emptyset), \Delta_D, \Gamma_D)$ where $\Delta_D$ and $\Gamma_D$ are defined as follows. 
			
			\begin{enumerate}
				\item $((S, S'), a, (R, R')) \in \Delta_D$ if $\rho_\Gamma((S,S'),a)=(R,R')$ where $R' \subsetneq R$
				\item \label{reset}$((S, S'), a, (R, \emptyset)) \in \Delta_D$ and $((S, S'), a, (R, \emptyset)) \in \Gamma_D$ if $\rho_\Gamma((S,S'),a)=(R,R)$ 
				\item No other transitions are in $\Delta_D$ and $\Gamma_D$
			\end{enumerate}
			
			%%Breakpoint automata recognize/describe/represent a subset of the original language 
			Figure \ref{fig:bp:non-equivalent} shows application of this construction. The example demonstrates that $\lD \subseteq \lA$ as the construction did not generate any accepting transition. Therefore original $\lA=\{a^\omega\}$, but $\lD$ is empty. 
			
			
			
			\begin{figure}[ht]
				\begin{center}
					\input{bp.tikz}
					
				\end{center}
				\caption{A Büchi Automaton $\cA$ (left) and a breakpoint automaton $\cD$ for $\cA$ (right). Inspired by \cite[Figure~7.3]{Blahoudek2018thesis}}
				\label{fig:bp:non-equivalent}
			\end{figure}
		
			\section{Slim automata}\label{section:slim}
			Slim automata are BP automata enriched with additional transitions. As a result, they are non-deterministic, Good for Markov decision processes \cite{hlavni} and equivalent to the input automata.	
			In this section we define transition function for \emph{strong slim} ($\gamma_{p}$)\cite{hlavni} and \emph{weak slim} ($\gamma_{w}$) automata,
			 $\gamma_w, \gamma_p:3^Q \times \Sigma \rightarrow 3^Q$, that promote the second set of a breakpoint construction to the first set as follows. 
			
			\begin{enumerate}
				\item if $\delta(S',a) = \gamma(S, a) = \emptyset$, then $\gamma_{p}((S,S'), a)$ and $\gamma_{w}((S,S'), a)$ are undefined, and
				\item otherwise
				$\gamma_{p}:((S,S'),a)=(\delta(S',a)\cup\gamma(S, a),\emptyset)$ and $\gamma_{w}:((S,S'),a)=(\delta(S',a),\emptyset)$
			\end{enumerate}
			
			
			$\cS\eqdef(\Sigma, 3^Q, (q_i,\emptyset), \Delta_S ,\Gamma_S)$ is (strong) slim, when  $\Gamma_p$ is generated by $\gamma_p$, then 
			$\Delta_S=\Delta_D \cup \Gamma_p$ is set of transitions, and
			$\Gamma_S=\Gamma_D \cup \Gamma_p$ is set of accepting transitions. $\lS = \lA$. The equivalence was proven in \cite{hlavni}.
			
			Alternatively, similarly defined using $\gamma_w$ instead of $\gamma_{p}$, automaton $\mathcal{W}\eqdef(\Sigma, 3^Q, (q_i,\emptyset), \Delta_W, \Gamma_W)$ is (weak) slim  when $\Gamma_w$ is generated by $\gamma_w$, then 
			$\Delta_W=\Delta_D \cup \Gamma_w$ is set of transitions, and
			$\Gamma_W=\Gamma_D \cup \Gamma_w$ is set of accepting transitions. $L(\mathcal{W}) = \lA$  (proof would go similarly like the one for strong slim).
			
			\begin{figure}[ht]
				\begin{center}
				\input{slim.tikz}
				\end{center}
				\caption{Slim automaton (right) and the original Büchi automaton from Figure \ref{fig:bp:non-equivalent}(left).  The image highlights underlying \textcolor{green}{breakpoint construction} by green color (as in Figure~\ref{fig:bp:non-equivalent}). A blue transition is created \textcolor{blue}{only by strong slim} transitions. State and transition  highlighted by red color would be created directly by \textcolor{red}{both weak and strong slim} transitions.  Let us note that state $\{\{\heaven\},\{\heaven\}\}$ is not part of produced automaton. It visualizes reset from breakpoint construction, step~\ref{reset}, which is applied even when the source state was created by slim transitions. }
				\label{fig:slim:equivalent}
			\end{figure}

			
	\chapter{Slim Automaton Construction Generalized to TGBA} \label{section:gslim}
			In this chapter, we discuss slim automata equivalent to a TGBA $\cT\eqdef(\Sigma, Q, q_i, \Delta, G)$.
			One possibility is to \emph{degeneralize} $\cT$ and to use the previously mentioned algorithm in section 2.3.
			In the rest of this chapter, we introduce a direct construction of slim TGBA equivalent to $\cT$.
			\paragraph{Extended slim construction}
			Intuitively, we will simulate the original automaton, by checking its accepting conditions one by one. In the original automaton have to go through an accepting transition of each accepting condition $g \in G=\{G_0, G_1, \ldots, G_k\}$ infinitely many times.
			In the new automaton, we have just one accepting condition and a layer for each original accepting condition. Going through original accepting transitions of the layer that we are looking up promotes us to another layer. From the last layer, we get back to the first layer. Only the transitions that move us to layer up are accepting. As we check all accepting conditions of the original automaton, the new automaton will be equivalent to the original one. We will use the word "levels" instead of layers in the following definitions.
			
			
			We need to make sure we go infinitely many times through each accepting subset $g \in G$.
			To achieve this, we will go through each subset one by one, using the original algorithm. We will keep track of $levels=\{0,1,\ldots,|G|-1\}$ in the names of states. Let $|G|$ be number of $levels$ and $i \in \mathbb{N}, i<|G|$ the current level.
			At each level $i$, we look at $i$th subset of $G$. We use the same steps as in classic breakpoint construction, but on each accepting transition, the new state will be leveled up to $(i+1)\bmod|G|$;
			 otherwise, the target state has the same level. Our new automaton simulates $\cT$, as it accepts a word if it cycles through all levels. If $|G|=0$, we return a trivially accepting automaton
			
			We can use the core of previous construction and just to extend it with levels.
			%$3^Q_i :=\{(S,S',i)|S'\subset S \subseteq Q, i \in N, i<|G|\}$ and
			%$3^Q_{i+}:=\{(S,S',i)|S'\subseteq S \subseteq Q, i \in N, i<|G|\}$.
	
			
			Let $(S,S')\in 3^Q$ and let $i \in levels$, by $P$ we denote a state $P=(S,S',i)$.
			%$\delta: (S,a)\rightarrow\{q'\in Q | \exists q \in S.(q,a,q') \in \Delta\}$ and
			
			%%$\gamma_{iS}: (S,a)\rightarrow\{q'\in Q | \exists q \in S.(q,a,q') \in G_i\}$
			We define $\gamma_i$ from $\Gamma_i$ for all $i \in levels$ in the same way we did for $\gamma$ from $\Gamma$. We use raw breakpoint transitions $\rho_{\Gamma}$ from tba breakpoint construction in Section~\ref{section:bp}.
			
			Let $up(x)=(x+1)\bmod|G|$.
			
			The generalized breakpoint automaton $\cD=(\Sigma, 3^Q\times\cN, ({q_i},\emptyset, 0),\Delta_B,\Gamma_B)$ is defined by breakpoint transitions ($\delta_B$ generates $\Delta_B$ and $\gamma_B$ generates $\Gamma_B$) as follows.
			
			When $\rho_{\Gamma} \colon((S,S'), a) \rightarrow (R, R')$, then for all $i \in levels$:
			
			For breakpoint transitions there are three cases:
			
			\begin{enumerate}
				\item if $R=\emptyset$ , then $\delta_B(P,a)$ is undefined,
				\item else, if $R \neq R'$, then $\delta_B((S,S',i),a) = (R,R',i)$ is a non-accepting transition,
				\item otherwise $\gamma_B(P, a) = \delta_B((S,S',i),a) = (R, \emptyset, up(i))$.
			\end{enumerate}
		
		
			%%	$\gamma_{p}: P \times \Sigma \rightarrow P$
			For slim transitions there are two additional cases:
			\begin{enumerate}
				\item if $\delta(S',a)=\gamma_{i}(S, a)=\emptyset$, then $ \gamma_{p}((S,S',i),a)$ is undefined, and
				\item otherwise $\gamma_p((S,S',i),a) = \gamma_p((S,S',i),a) = (\delta(S',a)\cup \gamma_{i}(S, a), \emptyset, up(i))$. (Alternatively, for a weak slim automaton we do not include transitions $\gamma_{i}(S, a)$)
			\end{enumerate}
			$\cS\eqdef(\Sigma, (S,S',i), (q_i,\emptyset,0), \Delta_S,\Gamma_S))$ is slim, when $\Delta_S=\Delta_B\cup\Delta_p$, generated by $\delta_B$ and $\gamma_p$, and $\Gamma_S=\Gamma_B\cup\Gamma_p$ is set of accepting transitions, that is generated by $\gamma_B$ and $\gamma_p$.
			
						
			\begin{figure}[ht]
				\begin{center}
					\input{tgba.tikz}
					
				\end{center}
				\caption{The original TGBA (top) and slim automaton with colored states emphasizing different levels (bottom).  }
				\label{fig:slim:gg}
			\end{figure}
			

			
	\chapter{Implementation} \label{implementation}
		I have implemented the generalized construction of slim automata in both weak and strong version  (\ref{section:slim}) (\ref{section:gslim}). I have also added option to create breakpoint automata (\ref{section:bp}).
		
		\section{Technologies/Tools}
		The implementation is inside Seminator, which is implemented in C++17 builds on Spot library. %\cite{DBLP:conf/mascots/Duret-LutzP04}.
		\subsection{Seminator} 
		Seminator is a Linux command-line tool which can be run with the \texttt{seminator} command. The tool transforms transition-based generalized Büchi automata (TGBAs) into equivalent semi-deterministic automata. \cite{Klokočka2017thesis}\cite{seminator}\cite{seminator2}
		
		
		
		The tool expects the input automaton in the Hanoi Omega-Automata (HOA) format \cite{DBLP:conf/cav/BabiakBDKKM0S15} on the standard input stream, but it can also read the input automaton from a file.
		
	\subsection{Spot}
	"Spot is a C++ library with Python bindings and an assortment of command-line tools designed to manipulate LTL and $\omega$-automata in batch." \cite[Abstract]{spot2}
	
	Relevant spot tools:
	\paragraph{ltl2tgba} "translates LTL/PSL formulas into generalized Büchi automata,or deterministic parity automata" \cite{spot}
	\paragraph{autfilt} "filters, converts, and transforms $\omega$-automata"  \cite{spot}
	\paragraph{ltlcross} "cross-compares LTL/PSL-to-automata translators to find bugs" \cite{spot}
		\section{Create Slim Automata Using Seminator}
		By default, seminator creates sDBA. To create a slim automaton we need to add -{}-slim option. 
		\paragraph{Options} By default, -{}-slim tries all reasonable combinations of options, optimizes the output and chooses an automaton with the smallest number of states.
		
		\paragraph{Example 1}
		Transform automaton.hoa to a slim automaton.

		\begin{lstlisting}[language=bash]
$./seminator --slim -f automaton.hoa
		\end{lstlisting}
		
		There are several options to specify how we construct the automata.
		
		For example \texttt{seminator -{}-slim -{}-strong -{}-optimizations=0 -{}-via-tgba} generates output according to algorithm in \ref{section:slim}. (Using \texttt{-{}-via-tba} converts input to tba first) With automaton
		
		
		\paragraph{Example 2}
		Transform automaton.hoa to unoptimized strong slim automaton
		\begin{lstlisting}[language=bash]
$./seminator --slim --strong --via-tgba --postprocess=0 -f automaton.hoa
		\end{lstlisting}
		
		 
		
		\texttt{-{}-slim }to generate slim automaton
		
		\texttt{-{}-weak} use only weak slim algorithm
		
		\texttt{-{}-strong} use only strong slim algorithm
		
		Neither weak nor strong option specified - try both options  and choose the one with a smaller automaton.
		
		\texttt{-{}-via-tba} transform input automaton to tba \ref{section:tba} first
		
		\texttt{-{}-via-tgba} does not modify input automaton to tba.
		
		Neither \texttt{-{}-via-tba} nor \texttt{-{}-via-tgba}: try both options, choose the smallest automaton.
		
		Postprocess optimizations are enabled by default.
		
		
	\section{Implementation of Slim Automata inside Seminator}
	I have implemented the generalized slim construction and its options mentioned in the previous section. Furthermore, I have added an option to create breakpoint automata.
	
	There already was a basis for breakpoint construction in seminator, inside class \texttt{bp\_twa}.
	As we can see in sections \ref{section:bp} and \ref{section:slim}, slim automata construction builds on breakpoint automata construction.
	
	That allows us to simply extend the \texttt{bp\_twa} class.
	We create class \texttt{slim} that inherits from \texttt{bp\_twa}.
	In the \texttt{slim} class we build breakpoint automaton using \texttt{compute\_successors} method.
	Then we extend the method by adding accepting transitions $\gamma_p$, respectively $\gamma_w$ according to section \ref{section:gslim}, whenever we receive \texttt{-{}-slim} option.
	
	Then we extend the main function to recognize our desired CLI options.
	
	As Seminator didn't offer a command-line option to create a breakpoint automaton, I have added the option \texttt{-{}-bp} for comparison.
	
	
	
	\section{Testing and Verification}
	Implemented tests are basic; only language equivalence is checked.
	ltlcross and ltl2tgba tools are used. The tests use random LTL formulas that were already generated. The LTL formulas are transformed into automata in HOA format by ltl2tgba.
	Then the tool ltlcross cross-compares the automaton with \emph{seminator -{}-slim} with all supported additional parameters.
	
	Only \texttt{seminator -{}-slim -{}-strong -{}-via-tba -{}-optimizations=0} is proved, as it follows construction from \cite{hlavni} which is proved.
	
	\section{Future of Implementation}
	Implementation:
	It would be good to optimize slim construction (especially from TGBA).
	
	
	
	Tests/verification:
	There should be another kind of test - to check if our slim automata simulate the input automata so the GFM property is not broken.
	
	The subject of the following research, which is out of the scope of this thesis, could be to verify if Spot's optimizations do not break the simulation property. 
	
	\chapter{Evaluation of automaton size}
	The evaluation part builds on seminator-evaluation. We compare the number of states of output automata on two datasets. The first dataset is 20 literature formulas; the second dataset is 500 automata that were randomly generated. We use a 120s timeout for each tool. The first section starts with an internal comparison of slim automata created by Seminator. The second section compares these automata against ePMC, which is another tool producing slim automata. The third section compares slim automata against ldba and semi-deterministic automata. Ldba automata are produced by ltl2ldba \cite{ltl2ldba}, and semi-deterministic automata are produced by Seminator. Let us note that from mentioned types of automata, only semi-deterministic automata do not promise good for Markov decision processes property.
	
	\section{Slim automata produced by Seminator}
	In this section we compare automaton size generated by \texttt{seminator --slim}.
	We compare weak against slim and via-tba against via-tgba.
	\subsection{Comparisons among Unoptimized Configurations}
	In this subsection we compare base unoptimized seminator options.
	
	In Table~\ref{table:seminator:unoptimized} strong slim automata have more states than weak ones, as expected because strong slim automata add more accepting transitions, which can create new states. Transformation of the automata to TBA first yields smaller automata. This might be caused by Spot having a well-optimized algorithm for degeneralization. The slim algorithm for TGBA proposed in this paper is naive, without any kind of optimizations, and it degeneralizes the automaton during the process.
\begin{table}[ht]
	\label{table:seminator:unoptimized}
	\centering
	\caption{Slim automata on both datasets without any post-processing (no timeouts).}
		\begin{tabular}{ |c||c|c|c|c| } 
			\hline
			seminator&\multicolumn{2}{c|}{weak}&\multicolumn{2}{c|}{strong} \\
			\hline
			literature&size&time(s)&size&time(s)\\
			\hhline{|=====|}
			
			via tba	&	1095	&4	& 1112 	&5\\
			\hline
			via tgba&	1122	&4		&1147	&4\\ 
			\hline
			\hline
			\hline
			seminator&\multicolumn{2}{c|}{weak}&\multicolumn{2}{c|}{strong} \\
			\hhline{|=====|}
			random&size&time(s)&size&time(s)\\
			\hline
			via tba&17567&	59& 18764 &57\\
			\hline
			via tgba&19320&	58& 20789&58\\ 
			\hline
		\end{tabular}
\end{table}
	\clearpage
	\subsection{Post-Optimized}
	In this subsection we post-optimize results using \texttt{autfilt} tool.
	
	GFM automata are closed under simulations \cite[Section~3.1]{hlavni}. We are confident that spot's \texttt{autfilt} does not break the property.
	
	\begin{table}[ht]
		
		\centering
		\caption{In this table we compare all possible post-optimized combinations of parameters. By default \texttt{seminator --slim} tries all combination, runs optimizations, and then chooses the smallest automaton (best/best). }
		\label{table:seminator:optimized}
		\begin{tabular}{ |c||c|c|c|c|c|c| } 
			\hline
			seminator&\multicolumn{2}{c|}{weak}&\multicolumn{2}{c|}{strong}&\multicolumn{2}{c|}{best} \\
			\hline
			literature&size&time[s]&size&time[s]&size&time[s]\\
			\hhline{|=======|}
			
			via tba&551&219& 370 &185& 370&404\\
			\hline
			via tgba&588&210& 408&174& 402&384\\ 
			\hline
			best&551&429& 370&359& 365&788 \\ 
			\hline
			
			
			\hline
			seminator&\multicolumn{2}{c|}{weak}&\multicolumn{2}{c|}{strong}&\multicolumn{2}{c|}{best} \\
			\hline
			random&size&time[s]&size&time[s]&size&time[s]\\
			\hhline{|=======|}
			via tba&8923&443& 7404 &476& 7219&919\\
			\hline
			via tgba&10130&654& 8500&591& 8247&1245\\ 
			\hline
			best&8751&1097& 7285&1067& 7088&2164 \\ 
			\hline
		\end{tabular}
	\end{table}

	
	As Table \ref{table:seminator:optimized} shows, from 4 base options, after applying post-optimizations strong slim algorithm surpasses a weak one by automaton size, even if it has worse results without the post-optimizations.
	Degeneralizing the automata as a first step still has smaller results.
	From 4 base options, the strong slim algorithm via-tba creates the smallest automata on average.
	Transforming input automata to tba first creates results that are close to the best ones. 
	
	
	\paragraph{Strong against weak slim automata}
	Let us focus on automaton size differences between weak and strong slim automata.
	
	Scatter plot~\ref{scatter:weakstrong} reveals that a strong slim automaton is smaller in the majority of cases, but there are also cases where a weak slim automaton is smaller than the strong one.
		\begin{figure}[ht]
			
			\centering 
			\caption{Scatter plot of strong against weak slim automata, equal values excluded. }
			\label{scatter:weakstrong}
		\begin{tikzpicture}
			\input{scatter/strong-weak.tikz}
		\end{tikzpicture}
	\end{figure}
	
		Comparing minimal hits for weak and strong automata in Table~\ref{table:weakstrongminhits} confirms that strong slim automata lead in unique minimal hits, but weak slim automata have some unique minimal hits too, so it makes sense to try both options and choose a better one. 
		\begin{table}[ht]
			\centering
			
			\caption{Minimal hits of strong and weak slim automata.}
			\label{table:weakstrongminhits}
			\begin{tabular}{ |c||c|c| } 
				\hline
				literature&unique minimal hits&minimal hits\\
				\hhline{|===|}
				weak&4 & 9\\
				\hline
				strong&11 & 16\\ 
				\hline
				\hline
				random&unique minimal hits&minimal hits\\
				\hhline{|===|}
				weak&68 & 202\\
				\hline
				strong&296 & 430\\ 
				\hline
			\end{tabular}
		\end{table}

		\paragraph{Via-tba against via-tgba}
		Let us note that 13/20 formulas from literature and 391/500 formulas from the random dataset create automata that are already TBA.
		
		Plot~\ref{scatter:tba-tgba} density is low, as many of the results are the same (the majority of the automata were already tba). Via-tba has mostly better results, but there are examples where via-tgba outputs automaton twice smaller automaton. Table~\ref{table:tba-tgba-min-hits} confirms that via-tba has better results. Via-tgba has only 9 minimal hits compared to 91 from via-tba.
		
		\begin{figure}[ht]
			\centering
			
		\caption{Scatter plot via-tba against via-tgba, equal values excluded. }
		\label{scatter:tba-tgba}
		\begin{tikzpicture}
			\input{scatter/tba-tgba.tikz}
		\end{tikzpicture}
		\end{figure}
		
		 
		\begin{table}[ht]
			
			\centering
			\caption{Minimal hits of via-tba against via-tgba.}
			\label{table:tba-tgba-min-hits}
			\begin{tabular}{ |c||c|c| } 
				\hline
				literature&unique minimal hits&minimal hits\\
				\hhline{|===|}
				via-tba&7 & 20\\
				\hline
				via-tgba&0 & 13\\ 
				\hline
				\hline
				random&unique minimal hits&minimal hits\\
				\hhline{|===|}
				via-tba&91 & 489\\
				\hline
				via-tgba&9 & 407\\ 
				\hline
			\end{tabular}
		\end{table}
	\clearpage
		\section{Slim Automata Produced Seminator versus ePMC}
		We can create slim automata using different tool called ePMC.
		
		At first, we compare the best working basic parameters (parameters that try only one option) of each tool to create the smallest automata to obtain a fair time comparison.
		As Table~\ref{table:epmc-seminator-1} shows, Seminator creates smaller automata and faster. In Figure~\ref{scatter:slim-epmc-1} we can see, that ePMC has some better hits.
	
	\begin{table}[ht]
		\centering
		
		\caption{EPMC acc stands for option, that uses accepting transitions whenever possible. It had slightly better results than other ePMC options. 120s timeouts are included in total time, however sum of automaton size is computed only from automata that were successfully created by both tools. }
		\label{table:epmc-seminator-1}
		\begin{tabular}{ |c||c|c|c| } 
			\hline
			literature&size&time[s]&timeouts\\
			\hhline{|====|}
			ePMC acc&650 &178&0 \\
			\hline
			Seminator tba strong &436 &151&0 \\
			\hlineny
			\hline
			random&size&time[s]&timeouts\\
			\hhline{|====|}
			ePMC acc&9643 & 5146&8\\
			\hline
			Seminator tba strong &7032 &405&2 \\
			\hlineny
		\end{tabular}
	\end{table}
	\begin{figure}[ht]
		\centering
		
		\caption{Scatter plot comparing sizes of ePMC acc and Seminator tba strong.}
		\label{scatter:slim-epmc-1}
		\begin{tikzpicture}
			\input{scatter/slim-epmc-1-option.tikz}
		\end{tikzpicture}
	\end{figure}
	
	
		The section compares the smallest automata of each tool to see how smaller automata get by combining these tools.
		
		As Figure~\ref{scatter:slim-epmc} shows, Seminator slim has most of the best results, and the difference is even bigger than the single option comparison in Figure~\ref{scatter:slim-epmc-1}. Combining Seminator and ePMC for best automata didn't bring much better results. On the random dataset total size of automata from Seminator slim is 7133. If we combine Seminator slim and ePMC, we get a total size of 7060, which is not a significant difference.
	
\begin{figure}[ht]
	\centering
	
	\caption{Scatter plot comparing smallest optimized automata generated by each tool. }
	\label{scatter:slim-epmc}
	\begin{tikzpicture}
		\input{scatter/slim-epmc.tikz}
	\end{tikzpicture}
\end{figure}
Then this section continues with comparison of minimal hits. Table~\ref{table:epmc-seminator-min-hits} shows that by unique minimal hits of these tool ePMC has 35 unique minimal hits compared to 344 of Seminator. But as we can see from previous scatter plot \ref{scatter:slim-epmc}, the size difference isn't that high.
\begin{table}[ht]
	\centering
	
	\caption{Comparison showing how many times tool got smallest or uniquely smallest automata.}
	\label{table:epmc-seminator-min-hits}
	\begin{tabular}{ |c||c|c| } 
		\hline
		literature&unique minimal hits&minimal hits\\
		\hhline{|===|}
		ePMC&1 & 5\\
		\hline
		Seminator &15 & 19\\ 
		\hline
		\hline
		random&unique minimal hits&minimal hits\\
		\hhline{|===|}
		ePMC&35 & 155\\
		\hline
		Seminator &344 & 464\\ 
		\hline
	\end{tabular}
\end{table}
		
	
	
	
		%%\subsection{Comparisons among Unoptimized options}
		%%\subsection{Comparisons among Post-Optimized options}
		
		
		%%\section{via tba/no change}
		%%\subsection{Comparisons among Unoptimized options}
		%%\subsection{Comparisons among Post-Optimized options}

		%\section{Slim automata produced seminator ePMC}
	\clearpage
		\section{Compare with Different Kinds of Automata}
		This section brings size comparison with diffent kinds of automata. It compares slim automata with ltl2ldba \cite{ltl2ldba}, default automata created by Seminator (semi-deterministic), and ePMC \cite{epmc}.
		
		Results of table~\ref{table:basic-tools} show that semi-deterministic automata created by Seminator are the smallest on average among the compared tools. Ltl2ldba creates the smallest GFM automata, as semi-deterministic automata do not promise GFM property.
		
		\begin{table}[ht]
			\centering
			
			\caption{Automata sizes after applying Spot's optimizations.}
			\label{table:basic-tools}
			\input{tables/basic-tools.tex}
		\end{table}
		
		
		
		Now we compare \texttt{seminator --slim} with other tools using scatter plots.
		
		Figure~\ref{scatter:seminator-slim-default} shows that semi-deterministic automata are consistently smaller or just slightly bigger than slim automata. 
		As Figure~\ref{scatter:seminator-ltl2ldba} shows, ltl2ldba creates consistently small automata (smaller than 40 states). However, its dominance over slim automata is not that consistent. The plot shows we can create reasonably smaller MDP automata on average using both tools and choosing the smallest automaton. Table~\ref{table:basic-tools-mix} confirms that. For the literature dataset, the mixed tool even beats semi-deterministic automata from Seminator.
		\begin{figure}[ht]
			\centering
			
			\caption{Comparison of semi-deterministic and slim automata created by Seminator.}
			\label{scatter:seminator-slim-default}
			\begin{tikzpicture}
				\input{scatter/slim-sem_def.tikz}
			\end{tikzpicture}
		\end{figure}
		
		\clearpage
		\begin{figure}[ht]
			\centering
			
			\caption{Slim automata from Seminator against automata from ltl2ldba.}
			\label{scatter:seminator-ltl2ldba}
		\begin{tikzpicture}
		\input{scatter/slim-ltl2ldba.tikz}
		\end{tikzpicture}
		\end{figure}
	
	\begin{table}[ht]
		\centering
		
		\caption{Automaton size comparison of Seminator slim + ltl2ldba combined tool against other tools.}
		\label{table:basic-tools-mix}
		\input{tables/basic-tools-mix.tex}
	\end{table}

	\chapter{Mungojerrie Benchmarks}
	This chapter compares Seminator's slim automata on reinforcement learning tool Mungojerrie \cite{mungojerrie}. Reinforcement learning inside Mungojerrie has 2 phases. It has a learning phase with a given number of episodes and a model checking phase. The objective is defined by provided GFM automaton.\cite{mungojerrie}
	
	
	The experiment uses benchmarks provided with the tool - Examples. Automata for the examples are built in various ways. Some can even be handcrafted. Using LTL, which is provided as a name of automaton in each original benchmark, we create slim automata for comparison on benchmarks, as Mungojerrie can accept LTL and transform it using internally supported tools ltl2ldba and ePMC, or we can provide automaton that is GFM (the property is not checked by Mungojerrie).
	
	
	Experiments are searching for the lowest necessary amount of episodes needed for reaching probability 1 to hit the objective in the model checking phase. Experiments run benchmarks ten times with pseudo-random seeds 0-9. If all runs end with success, the experiment computes the median and the average of results. A run can fail by timeout (600s) or by not reaching probability 1. We exclude uninteresting benchmarks, where all tools achieve the same result. 
	
	Table~\ref{Table:mungostats} shows that ltl2ldba has unique best results most often, but Seminator slim has some best hits too.
	
	Examples have unclear origins, therefore Table~\ref{Table:mungostatsnoex} shows the results without the Examples. Ltl2ldba still has the best unique results most often, but Seminator gets closer to ltl2ldba. Compared to the previous table, Seminator now has more best averages and medians than ltl2ldba. The table also shows ePMC having a higher amount of second-best averages and medians than other tools. 
	
	Table~\ref{Table:mungobenchmarks} contains average episodes needed for a benchmark for each tool. It is visualized by the cactus plot in Figure~\ref{Cactus:mungoaverage}. There we can see that ends of lines match a number of failures in tables~\ref{Table:mungostats}, \ref{Table:mungostatsnoex}.
	
	Figure~\ref{Cactus:mungoruns} shows the cactus plot of all benchmark runs. There we can observe that Seminator has the highest number of successful runs, therefore the lowest number of failures. It doesn't match the plot Figure~\ref{Cactus:mungoaverage}. The reasoning follows: Looking at the number of failures on Table~\ref{Table:mungostatsnoex}, both ePMC and ltl2ldba have one benchmark, which fails on all of its runs. Seminator has two benchmarks, which fail only on one run (by not achieving probability 1). Therefore Seminator succeeds at more runs than other tools in Figure~\ref{Cactus:mungoruns}.
	
	
	
	\begin{table}[ht]
		\centering
		
		\caption{Results with Examples included}
		\label{Table:mungostats}
		\input{mungostats.tex}
	\end{table}
	
	\begin{table}[ht]
		\centering
		
		\caption{Results with Examples excluded }
		\label{Table:mungostatsnoex}
		\input{tables/stats-noexamples.tex}
	\end{table}
	
	\begin{table}[ht]
		\centering
		
		\caption{Table of average episodes needed to reach probability 1.}
		\label{Table:mungobenchmarks}
		\input{mungobench.tex}
	\end{table}
	
	\begin{figure}[ht]
		\centering
		
		\caption{Sorted values for benchmark's average run for each tool by number of episodes (y-axis). Number of benchmarks is on x-axis. }
		\label{Cactus:mungoaverage}
		\input{cactuses/average.tikz}
	\end{figure}
	\begin{figure}
		\centering
		
		\caption{Sorted values for all of benchmark runs for each tool by number of episodes (y-axis). Number of benchmark runs is on x-axis. }
		\label{Cactus:mungoruns}
	\input{mungocactus.tikz}
	\end{figure}
	
	\chapter{Conclusions}
	
	I have described slim automata with its prerequisities (based on \cite{hlavni}) and its weak version.
	I have extended the construction to input TGBA automata.
	I have also implemented the construction of slim automata inside Seminator, which was the main goal.
	Then I have compared automaton size of slim automata and different tools.
	I have ended up with evaluating performance of Seminator's slim automata on recently released Mungojerrie tool.
	
	\begin{appendices}
	
	\chapter{List of Electronic Attachments}
	As part of thesis, I have also submitted the following electronic attachment:
	
	\texttt{seminator.zip} - Seminator which is released under the GNU GPL v3.0 license, extended by implementation of slim automata as described in Chapter~\ref{implementation}.
	\end{appendices}
\end{document}