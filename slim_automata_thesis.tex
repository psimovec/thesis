\documentclass[
	digital
nolof, nolot
]{fithesis3}

\usepackage{paratype}
\def\textrussian#1{{\usefont{T2A}{PTSerif-TLF}{m}{rm}#1}}

\thesissetup{
	date        = \the\year/\the\month/\the\day,
	university  = mu,
	faculty     = fi,
	type        = bc,
	author      = Pavel Šimovec,
	gender      = m,
	advisor     = {doc. RNDr. Jan Strejček, Ph.D.},
	title       = {Transformation of Nondeterministic Büchi Automata to Slim Automata},
	TeXtitle    = {Transformation of Nondeterministic Büchi Automata to Slim Automata},
	keywords    = {keyword1, keyword2, ...},
	TeXkeywords = {keyword1, keyword2, \ldots},
	abstract    = {%
		abstract
	},
	thanks      = {%
		RNDr. František Blahoudek, Ph.D.
	},
	bib         = {exampl.bib},
	%% Uncomment the following line (by removing the %% at the
	%% beginning) and replace `assignment.pdf` with the filename
	%% of your scanned thesis assignment.
	%%    assignment         = assignment.pdf,
}

%%\usepackage{amsmath}


\usepackage{makeidx}      %% The `makeidx` package contains
\makeindex                %% helper commands for index typesetting.
%% These additional packages are used within the document:
\usepackage{paralist} %% Compact list environments
\usepackage{amsmath}  %% Mathematics
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{url}      %% Hyperlinks
\usepackage{markdown} %% Lightweight markup
\usepackage{tabularx} %% Tables
\usepackage{tabu}
\usepackage{booktabs}
\usepackage{listings} %% Source code highlighting
\usepackage{emoji}
\usepackage{cancel}
\usepackage{hhline}

\usepackage{listings}

\usepackage{tikz}
\usetikzlibrary{myautomata}
\input{commands.tex}

\lstset{
	basicstyle      = \ttfamily,
	identifierstyle = \color{black},
	keywordstyle    = \color{blue},
	keywordstyle    = {[2]\color{cyan}},
	keywordstyle    = {[3]\color{olive}},
	stringstyle     = \color{teal},
	commentstyle    = \itshape\color{magenta},
	breaklines      = true,
}
\usepackage{floatrow} %% Putting captions above tables
\floatsetup[table]{capposition=top}

%% Calligraphy
\newcommand{\cA}{\mathcal{A}}
\newcommand{\cD}{\mathcal{D}}
\newcommand{\cN}{\mathcal{N}}
\newcommand{\cS}{\mathcal{S}}
\newcommand{\cT}{\mathcal{T}}

\newcommand{\lA}{L(\cA)}
\newcommand{\lD}{L(\cD)}
\newcommand{\lS}{L(\cS)}

%\newcommand{\eqdef}{\overset{\mathrm{def}}{=\joinrel=}}
\newcommand{\eqdef}{\overset{def}{=}}

\newcommand{\flushed}{\text{\emoji{flushed}}}
\newcommand{\hell}{\text{\emoji{fire}}}
\newcommand{\heaven}{\text{\emoji{innocent}}}

\newcommand{\hlineny}{\hline}

\begin{document}
	\chapter{Introduction}
	Büchi automaton\cite{textbook}\} is a finite machine over infinite words. It has been a topic of research for almost 60 years.
	There were discovered various kinds of similar machines with different properties and use cases.
	Non-deterministic Büchi in general are not well suitable for model checking or reinforcement, but we can construct non-deterministic Büchi automata with a special property - GFM, that makes the automata suitable. We will focus on slim automata~\cite{hlavni}.
	Slim automata are specially constructed from Büchi automata. This kind of automaton was defined by it's construction in [source] and is good for MDP [main source]. We implement the proposed algorithm and it's second variant that we call weak [source private conversation]. We extend the algorithm for generalised Büchi automata. Then we evaluate resulting size of automata and we compare it with different tool to create slim automata and with other kinds of automata.
	
	
	... slim automata are specially constructed Büchi automata.
	\chapter{Preliminaries}
		In this chapter we define a Büchi automaton and its generalized version.
		Then we continue with breakpoint algorithm. It allows us to introduce slim automata by its construction, which builds on the breakpoint one. Finally we generalize slim automaton construction to work with generalized Büchi automata.
		
		We will need to know that on \emph{alphabet} is a set of letters, an \emph{$\omega$-word} $w \in \Sigma^\omega$ is an infinite sequence of letters, and a \emph{language} $L \subseteq \Sigma^\omega$ is a set of $\omega$-words.
		\section{Büchi Automaton}
			A Büchi automaton is a theoretical finite-state machine used to define $\omega$-languages. It decides which infinitely long words ($\omega$-words) belong to its language.
			
			A \emph{transition-based Büchi automaton (TBA)} is a tuple $\cA\eqdef(\Sigma, Q, q_i, \Delta, \Gamma)$, where 
			\begin{itemize}
				\item $\Sigma$ is a non-empty finite \emph{alphabet},
				\item $Q$ is a non-empty finite set of \emph{states},
				\item $q_i \in Q$ is the initial state of $\cA$.
				\item We write the set of \emph{transitions} as $\Delta \subseteq Q \times \Sigma \times Q$. Intuitivelly, a transition $(s, a, t)$  directionally connects the states $s$ and $t$ with the letter $a$.
				\item $\Gamma \subseteq \Delta$ is a set of \emph{accepting transitions}.
			\end{itemize}
			
			A \emph{run} $r$ of $\cA$ is an infinite sequence of transitions
			$r\eqdef t_0t_1\ldots\in\Delta^\omega$, where $t_i=(s_i, a_i,s_{i+1})$,
			 such that $q_0=q_i$.
			A run of $\cA$ is \emph{accepting} iff it contains infinitely many accepting transitions.

			Finally, we define the \emph{language} $\lA \subseteq \Sigma^\omega$ recognized by the automaton $\cA$. An $\omega$-word $w \in \Sigma^\omega$ belongs to $\lA$ iff there exists an accepting run of $\cA$ over the word $w$. 
			
			
		\section{Generalized Büchi Automaton}
		A \emph{transition-based Generalized Büchi automaton} (TGBA) is a tuple $\cA\eqdef(\Sigma, Q, q_i, \Delta, G)$, where $\emptyset \subseteq G \subseteq 2^\Delta$ contains sets of accepting conditions and the rest is defined as for TBA. A run of $\cA$ is \emph{accepting} iff it contains infinitely many accepting transitions \emph{for each} $\Gamma \in G$. TBA can be seen as a special case of TGBA with $|G|=1$
		
		\section{Breakpoint Automaton}
		We want to define \emph{slim Büchi automaton} (slim automaton) through its construction which is based on breakpoint construction.
		Breakpoint (BP) automata are a building block for slim automata. BP automata are constructed from BA and are deterministic, but their language is only a subset of the language from original BA. 
		
		\paragraph{Construction}
		Let us fix a Büchi Automaton $\cA\eqdef(\Sigma, Q, q_i, \Delta, \Gamma)$. 
		
		%%We want to construct a deterministic automaton $\cD$ such that $\lD\subseteq \lA$ 
		By $3^Q$ we denote the set $\{(S,S') \mid S'\subsetneq S \subseteq Q\}$ and
		by $3^Q_+$ we denote $\{(S,S') \mid S'\subseteq S \subseteq Q\}$.
		
		%%We define the notation for the transitions and accepting transitions as $\delta,\gamma:2^Q \times \Sigma \rightarrow 2^Q$ with
		
		Given the set of transitions, we define the function $\delta \colon 2^Q \times \Sigma \rightarrow 2^Q$ as 	
			$\delta\colon (S,a)\eqdef\{q'\in Q \mid \exists q \in S.(q,a,q') \in \Delta\}$. We define $\gamma:2^Q  \times \Sigma \rightarrow 2^Q$ analogously from $\Gamma$ as $\gamma: (S,a)\eqdef\{q'\in Q \mid \exists q \in S.(q,a,q') \in \Gamma\}$.
			
			%%$\gamma: (S,a)\eqdef\{q'\in Q \mid \exists q \in S.(q,a,q') \in \Gamma\}$
			By definitions, $\delta$ and $\gamma$ are deterministic transition functions.
			
			Using $\Delta$, we define the raw breakpoint transition
			$\rho_\Gamma \colon 3^Q \times \Sigma \rightarrow 3^Q_+$ as
			\[\rho_\Gamma((S, S'), a) \eqdef(\delta(S, a), \delta(S',a)\cup \gamma(S, a))\]
			We follow the set of reachable states in the first set and the states that are reachable while passing at least one of the accepting transitions in the second set.
			The transitions of the breakpoint automaton $\cD$ follow $\rho$ with an exception: they reset the second set to the empty set when it equals the first; the resetting transitions are accepting.
			Formally, the breakpoint automaton $\cD$ is $ \eqdef (\Sigma, 3^Q, (q_i, \emptyset), \delta_D, \gamma_D)$  $\rho\colon ((S, S'), a) = (R, R')$, then there are three cases:
			
			\begin{enumerate}
				\item if $R=\emptyset$, then $\delta_D((S,S'))$ is undefined (or, if a complete automation is preferred, maps to a rejecting sink),
				\item else, if $R \neq R'$, then $\delta_D((S,S'),a)=(R, R')$ is a non-accepting transition,
				and $\gamma_D((S,S'),a)$ is undefined.
				\item otherwise $\delta_D((S,S')=\gamma_D((S,S'),a)=(R, \emptyset)$ is an accepting transition.
			\end{enumerate}
			
			%%Breakpoint automata recognize/describe/represent subset of original language 
			Figure \ref{fig:bp:non-equivalent}) shows application of this construction. 
			
			
		
			\begin{figure}[ht]
				\begin{center}
					\begin{tikzpicture}[automaton]
						\node[state,initial] (a) {\flushed};
						\node[state,right = 1 cm of a] (b) {\hell};
						\node[state,above = 1 cm of a] (c) {\heaven};
						
						\node[right = 2cm of b,state,initial, sd green] (bp-0) {$\{\flushed\},\emptyset$};
						\node[state,right = 1cm of bp-0, sd green] (bp-12) {$\{\hell,\heaven\}, \emptyset$};
						\node[state,above = 1cm of bp-12, sd green] (bp-12-1) {$\{\hell,\heaven\}, \{\heaven\}$};
						
						\path[->,auto ]
						(c) edge[loop above] pic[] {eacc=0} pic{l=$a$} (c)
						(a) edge[] node {$a$} (c)
						(a) edge[] node {$a$} (b)
						(b) edge[loop above] node {$a$} (b)
						;
						\path[->,auto ]			
						(bp-0) edge[] node {$a$} (bp-12)
						(bp-12) edge[] node {$a$} (bp-12-1)
						(bp-12-1) edge[loop above] node {$a$} (bp-12-1)
						;
					\end{tikzpicture}
				\end{center}
				\caption{Example of breakpoint automaton $\cD$ (right) non-equivalent with the original Buchi Automaton $\cA$ (left). The example demonstrates that $\lD \subseteq \lA$ as the construction did not generate any accepting transition. Therefore original $\lA=\{a^\omega\}$, but $\lD$ is empty.}
				\label{fig:bp:non-equivalent}
			\end{figure}
			
			
			
			\section{Slim Automata Construction}\label{section:slim}
			
			%%todle mozna trochu jinak v (ne dalsi ale) teto sekci
			%%We are going to define a few more transitions on top of breakpoint construction which allow us to construct slim automata that decide exactly the class of <GFM languages> spatny pojem. jsou to omega regularni
			
			%Breakpoint automata constructed as presented in the previous section are not always equivalent to the input automaton, but are deterministic. Slim automata are equivalent to do not hold the deterministic property, however they are GFM\footnote{Good for Markov decision processes [+zdroj]}
			
			Slim automata are BP automata enriched with additional transitions. As a result they are non-deterministic, GFM\footnote{Good for Markov decision processes [+zdroj]} and equivalent to input automaton.
			
			In this section we define transitions  $\gamma_w, \gamma_p:3^Q \times \Sigma \rightarrow 3^Q$ that promote the second set of a breakpoint construction to the first set as follows. 
			
			\begin{enumerate}
				\item if $\delta_S(S',a) = \gamma_S(S, a) = \emptyset$, then $\gamma_{p}((S,S'), a)$ and $\gamma_{w}((S,S'), a)$ are undefined, and
				\item otherwise
				$\gamma_{p}:((S,S'),a)=(\delta(S',a)\cup\gamma(S, a),\emptyset)$ and $\gamma_{w}:((S,S'),a)=(\delta(S',a),\emptyset)$
			\end{enumerate}
			
			
			$\cS\eqdef(\Sigma, 3^Q, (q_i,\emptyset), \Delta_S ,\Gamma_S)$ is slim, when
			$\Delta_S=\Delta_D \cup \Gamma_p$ is set of transitions generated by $\delta_D$ and $\gamma_p$, and
			$\Gamma_S=\Gamma_D \cup \Gamma_p$ is set of accepting transitions, that is generated by $\gamma_D$ and $\gamma_p$. $\lS = \lA$. The equivalence was proven in \cite{hlavni}.
			
			Alternatively, similarly defined using $\gamma_w$ instead of $\gamma_{p}$, automaton $\mathcal{W}\eqdef(\Sigma, 3^Q, (q_i,\emptyset), \Delta_w, \Gamma_w)$ is slim a and $\lS=\lA$. (no proof yet)
			
			\begin{figure}[ht]
				\begin{center}
					\begin{tikzpicture}[automaton]
						\node[state,initial] (a) {\flushed};
						\node[state,right of = a] (b) {\hell};
						\node[state,above of = a] (c) {\heaven};
						
						\node[right = 2cm of b,state,initial, sd green] (bp-0) {$\{\flushed\},\emptyset$};
						\node[state,right = 1cm of bp-0, sd green] (bp-12) {$\{\hell,\heaven\}, \emptyset$};
						\node[state,above = 1cm of bp-12, sd green] (bp-12-1) {$\{\hell,\heaven\}, \{\heaven\}$};
						\node[state,above = 1cm of bp-0, sd red] (bp-2) {$\{\heaven\}, \emptyset$};
						\node[state,above = 1cm of bp-2, cstate, unreachable] (bp-2-2) {$\{\heaven\}, \{\heaven\}$};
						
						\path[->,auto ]
						(c) edge[loop above] pic[] {eacc=0} pic{l=$a$} (c)
						(a) edge[] node {$a$} (c)
						(a) edge[] node {$a$} (b)
						(b) edge[loop above] node {$a$} (b)
						;
						\path[->,auto ]			
						(bp-0) edge[] node {$a$} (bp-12)
						(bp-12) edge[] node {$a$} (bp-12-1)
						(bp-12-1) edge[loop above] node {$a$} (bp-12-1)
						(bp-12-1) edge[red] pic[] {eacc=0} pic{l=$a$} (bp-2)
						(bp-2) edge[loop above] pic[] {eacc=0} pic{l=$a$} (bp-2)
						(bp-2) edge[unreachable, bend left] node {$a$} (bp-2-2)
						;
					\end{tikzpicture}
				\end{center}
				\caption{Slim automaton (right) and the original Buchi Automaton from Figure \ref{fig:bp:non-equivalent}(left)}
				\label{fig:slim:equivalent}
			\end{figure}

			
			\chapter{Slim Automaton Construction Generalized to TGBA}
			We want to construct a slim automaton from TGBA $\cT\eqdef(\Sigma, Q, q_i, \Delta, G)$.
			One possibility is to \emph{degeneralize} $\cT$ and to use previously mentioned algorithm in section 2.3. Another way is to extend slim automaton construction to TGBA.
			\paragraph{extended slim construction}
			We need to make sure we go infinitely many times trough each accepting subset $g \in G$. To achieve this, we will go through each subset one by one, using original algorithm. We will keep track of $levels\eqdef\{0,1,\ldots,|G|-1\}$ in the names of states. Let $|G|$ be number of $levels$ and $i \in N, i<|G|$ the current level. At each level $i$, we look at $i$th subset of $G$. We use same steps as in classic breakpoint construction, but on each accepting transition the new state will be leveled up to $(i+1)\bmod|G|$, otherwise the target state has the same level. Our new automaton simulates $\cT$, as it accepts a word iff it cycles through all levels. If $|G|=0$, we return a trivially accepting automaton
			
			We can use the core of previous construction and just to extend it with levels. Let
			$up(x)\eqdef(x+1)\bmod|G|$ 
			%$3^Q_i :=\{(S,S',i)|S'\subset S \subseteq Q, i \in N, i<|G|\}$ and
			
			%$3^Q_{i+}:=\{(S,S',i)|S'\subseteq S \subseteq Q, i \in N, i<|G|\}$.
			
			$P := 3^Q \times levels$ (?nepotrebuju and $P_+ := 3^Q_+ \times levels$)
			
			%$\delta: (S,a)\rightarrow\{q'\in Q | \exists q \in S.(q,a,q') \in \Delta\}$ and
			
			%%$\gamma_{iS}: (S,a)\rightarrow\{q'\in Q | \exists q \in S.(q,a,q') \in G_i\}$
			We define $\gamma_i$ similarly like $\gamma$, we just use $\Gamma_i$ instead of $\Gamma$ and it allows us to easily define the raw generalized breakpoint transitions
			$\rho_{\Gamma_{i}}\colon$ similarly as $\rho_\Gamma$ using $\gamma_i$ instead of $\gamma$.
			
			The generalized breakpoint automaton $\cD=(\Sigma, 3^Q\times\cN, ({q_i},\emptyset, 0))$ is defined such that, when $\delta_R\colon((S, S', i), a) \rightarrow (R, R', j)$, then there are three cases:
			\begin{enumerate}
				\item if $R=\emptyset$ , then $\delta_B((S,S',i))$ is undefined,
				\item else, if $R \neq R'$, then $\delta_B\colon((S,S',i),a) = (R,R',i)$ is a non-accepting transition,
				\item otherwise $\delta_B, \gamma_B \colon \delta_B((S,S',i),a) = (R, \emptyset, up(i))$.
			\end{enumerate}
		
		
				$\gamma_{p}: P \times \Sigma \rightarrow P$
			\begin{enumerate}
				\item if $\delta(S',a)=\gamma_{i}(S, a)=\emptyset$, then $ \gamma_{p}((S,S',i),a)$ is undefined, and
				\item otherwise $\gamma_p \colon ((S,S',i),a) = (\delta(S',a)\cup \gamma_{i}(S, a), \emptyset, up(i))$.
			\end{enumerate}
			$\cS\eqdef(\Sigma, P, (q_i,\emptyset,0), \Delta_p,\Gamma_p))$ is slim, when $\Delta_p$ is set of transitions generated by $\delta_b$ and $\gamma_p$, and $\Gamma_p$ is set of accepting transitions, that is generated by $\gamma_b$ and $\gamma_p$.
			
						
			\begin{figure}[ht]
				\begin{center}
					\begin{tikzpicture}[automaton]
						\node[state,initial] (a) {A};
						\node[state,above of = a] (d) {D};
						
						\node[below = 6cm of a,state,initial, cd blue] (bp-a-0) {$\{A\},\emptyset,0$};
						\node[state,right = 1cm of bp-a-0, cd blue] (bp-d-0) {$\{D\}, \emptyset,0$};
						\node[state,right = 1cm of bp-d-0, cd blue] (bp-ad-0) {$\{A,D\}, \emptyset,0$};
						\node[state,right = 1cm of bp-ad-0, cd blue] (bp-ad-a-0) {$\{A,D\}, \{A\},0$};
						\node[above = 2cm of bp-a-0,state, cd orange] (bp-a-1) {$\{A\},\emptyset,1$};
						\node[state,above = 2cm of bp-d-0, cd orange] (bp-d-1) {$\{D\}, \emptyset,1$};
						\node[state,above = 2cm of bp-ad-0, cd orange] (bp-ad-1) {$\{A,D\}, \emptyset,1$};
						\node[state,above = 2cm of bp-ad-a-0, cd orange] (bp-ad-d-1) {$\{A,D\}, \{D\},1$};
						
						\path[->,auto ]
						(a) edge[loop below] pic[] {eacc=0} pic{l=$a$} (a)
						(a) edge[bend left] node {$c$} (d)
						(d) edge[loop right] node {$c$} (d)
						(d) edge[bend left] node {$c$} (a)
						(d) edge[loop above] pic[] {eacc=1} pic{l=$d$} (d)
						;
						\path[->,auto ]
						(bp-a-0) edge[bend right] node {$c$} (bp-d-0)
						(bp-d-0) edge[bend right] node {$c$} (bp-ad-0)
						(bp-a-1) edge[bend left] node {$c$} (bp-d-1)
						(bp-d-1) edge[bend left] node {$c$} (bp-ad-1)
						
						(bp-a-1) edge[loop above] node {$a$} (bp-a-1)
						(bp-d-0) edge[loop below] node {$d$} (bp-d-0)
						
						(bp-ad-d-1) edge[loop above] node {$a$} (bp-ad-d-1)
						(bp-ad-a-0) edge[loop below] node {$d$} (bp-ad-a-0)
						
						(bp-a-0) edge[blue]  pic[] {eacc=3} pic{l=$a$} (bp-a-1)
						(bp-ad-0) edge[ blue]  pic[] {eacc=3} pic{l=$a$} (bp-a-1)
						(bp-ad-a-0) edge[ blue]  pic[] {eacc=3} pic{l=$a$} (bp-a-1)
						(bp-d-1) edge[orange]  pic[] {eacc=3} pic{l=$d$} (bp-d-0)
						(bp-ad-1) edge[orange]  pic[] {eacc=3} pic{l=$d$} (bp-d-0)
						(bp-ad-d-1) edge[orange]  pic[] {eacc=3} pic{l=$d$} (bp-d-0)
						
						(bp-ad-0) edge[bend right] node {$a$} (bp-ad-a-0)
						(bp-ad-1) edge[bend left] node {$d$} (bp-ad-d-1)
						
						(bp-ad-0) edge[loop below] node {$c$} (bp-ad-0)
						(bp-ad-1) edge[loop above] node {$c$} (bp-ad-1)
						
						
						(bp-ad-d-1) edge[orange] pic[] {eacc=3} pic{l=$c$} (bp-ad-0)
						(bp-ad-a-0) edge[ blue] pic[] {eacc=3} pic{l=$c$} (bp-d-1)
						
						
						;
					\end{tikzpicture}
				\end{center}
				\caption{Slim automaton (bottom) and the original TGBA(top)}
				\label{fig:slim:gg}
			\end{figure}
			

			
	\chapter{Implementation}
		I have implemented the generalized construction of slim automata in both weak and strong version (2.4,2.5). I have also added option to create breakpoint automata (2.3).
		
		\section{Technologies/Tools}
		The implementation is inside seminator, which is implemented in C++17 builds on Spot library[24-mklokocka].
		\subsection{Seminator} [zdroj mklokocka thesis] 
		Seminator is a Linux command-line tool which can be run with the seminator command.
		
		The tool expects the input automaton in the Hanoi Omega-Automata(HOA) format [25-mklokocka] on the standard input stream, but it can also read the input automaton from a file.
		
		[EXAMPLE OF sDBA created by seminator?]
		
	\subsection{Spot}
			\paragraph{ltl2tgba}...
	\paragraph{autfilt}...
	\paragraph{ltlcross}...
		\section{Create Slim Automata Using Seminator}
		By default, seminator creates sDBA. To create a slim automaton we need to add -{}-slim option. 
		\paragraph{Options} By default, -{}-slim tries all reasonable combinations of options, optimizes the output and chooses an automaton with the smallest number of states.
		
		There are several options to specify how we construct the automata.
		
		For example \texttt{seminator -{}-slim -{}-strong -{}-optimizations=0 -{}-via-tgba} generates output according to algorithm in 2.5. (Using \texttt{-{}-via-tba} converts input to tba first) With automaton
		
		[TBA (or TGBA?) INPUT EXAMPLE]
		
		\begin{lstlisting}[language=bash]
$ cat automaton.hoa | ./seminator --slim --strong --via-tgba --optimalizations=0
		\end{lstlisting}
		
		we will get output
		
		[SLIM OUTPUT EXAMPLE]
		 
		
		-{}-slim to generate slim automata by, defaults to unoptimized, "strong" slim algorithm
		
		-{}-weak use "weak"-slim algorithm instead
		
		-{}-best try weak and strong, optimize outputs with spot and choose the one with smaller automaton [delete and use as default]
		
		(add -{}-strong to generate just automata just by strong slim algorithm)
		[not implemented yet] neither --weak nor --strong specified try both, optimize and choose smaller result
		
		-{}-via-tba transform input automaton to tba (2.1) first
		
		-{}-via-tgba does not modify input automaton to tba.
		
		neither -{}-via-tba nor -{}-via-tgba: try both options, choose smallest automaton
		
		postprocess optimalizations  should be used be as a default option, use an option to disable
		
		\paragraph{Example}
		Transform automaton.hoa to a slim automaton.
		\begin{lstlisting}[language=bash]
$ cat automaton.hoa | ./seminator --slim
		\end{lstlisting}
	\section{Implementation of Slim Automata inside Seminator}
	I have implemented the generalized slim construction and its options mentioned in previous section 3.2. Furthermore, I have added an option to create breakpoint automata.
	
	There already was basis for breakpoint construction in seminator, inside class \texttt{bp\_twa}.
	As we can see in sections 2.3 and 2.4, slim automata construction builds on breakpoint automata construction.
	
	That allows us to simply extend the \texttt{bp\_twa} class.
	We create class \texttt{slim} that inherits from \texttt{bp\_twa}.
	In the \texttt{slim} class we build breakpoint automaton using \texttt{compute\_successors} method.
	Then we extend the method by adding accepting transitions $\gamma_p$, respectively $\gamma_w$ according to section 2.4, whenever we receive \texttt{-{}-slim} option.
	
	Then we extend main function to recognize our desired CLI options.
	
	As seminator didn't offer a command line option to create a bp automaton, I have added one ,-{}-bp, for comparison.
	
	
	
	\section{Testing and Verification}
	Implemented tests are basic, only language equivalence is checked.
	ltlcross and ltl2tgba tools are used. The tests use random LTL formulas that were already generated, the LTL formulas are transformed into automata in HOA format by ltl2tgba.
	Then the tool ltlcross cross-compares the automaton with \emph{seminator -{}-slim} with all supported [not yet] additional parameters.
	
	Only \emph{seminator -{}-slim -{}-strong -{}-via-tba} (and with no optimalizations) is proved, as it follows construction from [main source] which is proved.
	
	
	\section{How to Install Seminator}
	(jeste nevim kde tuto sekci dat, jestli ma mit tento nazev, co vsechno tady bude treba dat... no a jeste ro pak upravim podle toho jak to bude odevzdane v zipu)
	
	To install the tool we need install spot and to run 
	
	\begin{lstlisting}[language=bash]
autoreconf -i && ./configure && make.
	\end{lstlisting}
	\section{Future of Implementation}
	Implementation:
	python bindings, optimizations of slim construction (especially from TGBA)
	
	
	
	tests/verification:
	There should be another kind of tests - to check if our slim automata simulate the input automata (so the GFM property is not broken)
	
	Subject of following research, that is out of scope of this thesis, could be to verify if spot optimizations do not break the simulation property. 
	
	\chapter{Evaluation}
	Evaluation part builds on seminator-evaluation. We compare amount of states of output automata. We compare the data on 2 dataset. First dataset are 20 literature formulas, second dataset is 500 automata that were randomly generated.
	
	
	\section{Seminator -\/-slim}
	In this section we compare automaton size generated by seminator -{}-slim.
	We compare weak against slim and via-tba against via-tgba.
	\subsection{Comparisons among Unoptimized Configurations}
	In this subsection we compare base unoptimized seminator options.
\begin{table}[ht]
	\centering
	\caption{literature: unoptimized seminator -\/-slim}
		\begin{tabular}{ |c||c|c|c|c| } 
			\hline
			seminator&\multicolumn{2}{c|}{weak}&\multicolumn{2}{c|}{strong} \\
			\hline
			literature&size&time(s)&size&time(s)\\
			\hhline{|=====|}
			
			via tba&5x51&21x9& 37x0 &1x85\\
			\hline
			via tgba&5x88&21x0& 40x8&1x74\\ 
			\hline
		\end{tabular}
\end{table}
	
	
	\begin{table}[ht]
		\centering
		\caption{random: unoptimized seminator -\/-slim}
		\begin{tabular}{ |c||c|c|c|c| } 
			\hline
			seminator&\multicolumn{2}{c|}{weak}&\multicolumn{2}{c|}{strong} \\
			\hhline{|=====|}
			random&size&time(s)&size&time(s)\\
			\hline
			via tba&551&219& 370 &185\\
			\hline
			via tgba&588&210& 408&174\\ 
			\hline
		\end{tabular}
\end{table}
	
	
	Transforming automata to TBA first yields smaller automata. This might be caused by Spot having well optimized algorithm for degeneralization. Slim algorithm for TGBA proposed in this paper is naive, without any kind of optimizations, and it degeneralizes the automaton during the process.
	
	Using weak slim algorithm creates smaller slim automata than the strong one. 

	\subsection{Post-Optimized}
	In this subsection we post-optimize results using autfilt.
	
	literature
	\begin{center}
		\begin{tabular}{ |c||c|c|c|c|c|c| } 
			\hline
			seminator&\multicolumn{2}{c|}{weak}&\multicolumn{2}{c|}{strong}&\multicolumn{2}{c|}{best} \\
			\hline
			literature&size&time(s)&size&time(s)&size&time(s)\\
			\hhline{|=======|}
			
			via tba&551&219& 370 &185& 370&404\\
			\hline
			via tgba&588&210& 408&174& 402&384\\ 
			\hline
			best&551&429& 370&359& 365&788 \\ 
			\hline
		\end{tabular}
	\end{center}
	
	500 randomly generated automata
	\begin{center}
		\begin{tabular}{ |c|c|c|c|c|c|c| } 
			\hline
			seminator&\multicolumn{2}{c|}{weak}&\multicolumn{2}{c|}{strong}&\multicolumn{2}{c|}{best} \\
			\hline
			random&size&time(s)&size&time(s)&size&time(s)\\
			\hline
			via tba&8923&443& 7404 &476& 7219&919\\
			\hline
			via tgba&10130&654& 8500&591& 8247&1245\\ 
			\hline
			best&8751&1097& 7285&1067& 7088&2164 \\ 
			\hline
		\end{tabular}
	\end{center}
	
	From 4 base options; after applying post-optimizations strong slim algorithm surpasses weak one by resulting automaton size, even if it has worse results without the post-optimizations.
	Degeneralizing the automata as a first step still has smaller results.
	From 4 base options, strong slim algorithm via-tba creates smallest automata on average.
	Transforming input automata to tba first creates results which are close to best ones. If execution time is not a concern
	
		\subsubsection{Minimal hits for random automata weak x strong}
		\begin{center}
			\begin{tabular}{ |c|c|c| } 
				\hline
				literature&unique minimal hits&minimal hits\\
				\hline
				weak&4 & 9\\
				\hline
				strong&11 & 16\\ 
				\hline
			\end{tabular}
		\end{center}
	\begin{center}
		\begin{tabular}{ |c|c|c| } 
			\hline
			random&unique minimal hits&minimal hits\\
			\hline
			weak&68 & 202\\
			\hline
			strong&296 & 430\\ 
			\hline
		\end{tabular}
	\end{center}
		\subsubsection{Minimal hits for random automata via-tba versus via-tgba}
		Let us note that 13/20 formulas from literature and 391/500 formulas from random dataset create automata that are already TBA. 
		\begin{center}
			\begin{tabular}{ |c|c|c| } 
				\hline
				literature&unique minimal hits&minimal hits\\
				\hline
				via-tba&7 & 20\\
				\hline
				via-tgba&0 & 13\\ 
				\hline
			\end{tabular}
		\end{center}
				\begin{center}
			\begin{tabular}{ |c|c|c| } 
				\hline
				random&unique minimal hits&minimal hits\\
				\hline
				via-tba&91 & 489\\
				\hline
				via-tgba&9 & 407\\ 
				\hline
			\end{tabular}
		\end{center}
	
		\section{Slim Automata Produced Seminator versus ePMC}
		popsat co to je ePMC+zdroj
		prvne jedna vybrana moznost
		
		At first we compare best working basic paramaters (parameters that try only 1 option) of each tool to create smallest automata

	\begin{center}
		\begin{tabular}{ |c|c|c| } 
			\hline
			random&size&time(s)\\
			\hline
			epmc acc&9270 & \\
			\hline
			seminator tba strong &6840 & \\
			\hlineny
		\end{tabular}
	\end{center}
	\begin{center}
		\begin{tabular}{ |c|c|c| } 
			\hline
			random&size&time(s)\\
			\hline
			epmc acc&9270 & \\
			\hline
			seminator tba strong &6840 & \\
			\hlineny
		\end{tabular}
	\end{center}
		Now let us compare smallest automata of each tool and to see how smaller automata get by combining these 2 tools.
		\begin{center}
			\begin{tabular}{ |c|c|c| } 
				\hline
				literature&size&time(s)\\
				\hline
				epmc best&536 & \\
				\hline
				seminator best &365 & \\
				\hlineny
				seminator+epmc best &349 & \\ 
				\hlineny
			\end{tabular}
		\end{center}
	\begin{center}
		\begin{tabular}{ |c|c|c| } 
			\hline
			random&size&time(s)\\
			\hline
			epmc best&10197 & \\
			\hline
			seminator best &7133 & \\
			\hlineny
			seminator+epmc best &7060 & \\ 
			\hlineny
		\end{tabular}
	\end{center}
\begin{center}
	\begin{tabular}{ |c|c|c| } 
		\hline
		literature&unique minimal hits&minimal hits\\
		\hline
		epmc&1 & 5\\
		\hline
		seminator &15 & 19\\ 
		\hline
	\end{tabular}
\end{center}
		\begin{center}
			\begin{tabular}{ |c|c|c| } 
				\hline
				random&unique minimal hits&minimal hits\\
				\hline
				epmc&35 & 155\\
				\hline
				seminator &344 & 464\\ 
				\hline
			\end{tabular}
		\end{center}
		%%\subsection{Comparisons among Unoptimized options}
		%%\subsection{Comparisons among Post-Optimized options}
		
		
		%%\section{via tba/no change}
		%%\subsection{Comparisons among Unoptimized options}
		%%\subsection{Comparisons among Post-Optimized options}
		\ref{section:slim}
		(2.5)
		%\section{Slim automata produced seminator ePMC}
		prvne tba zkusit pro epmc
		\section{Compare with semi-deterministic Automata}
			\begin{center}
			\begin{tabular}{ |c|c|c| } 
				\hline
				random&size&time(s)\\
				\hline
				ltl2tgba&3000cca & \\
				\hline
				seminator default &3700 & \\
				\hlineny
				seminator slim best &7060 & \\ 
				\hlineny
			\end{tabular}
		\end{center}
		\section{To Put Somewhere in This Chapter}
		If the automata optimizations by spot's 
		\texttt{autfilt} tool break the simulation property, the results in following Evaluation chapter are pointless, as they are built on such assumption.
	\chapter{Conclusion}
\end{document}