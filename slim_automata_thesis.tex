\documentclass[
	digital,
nolof, nolot
]{fithesis3}

\usepackage{paratype}
\def\textrussian#1{{\usefont{T2A}{PTSerif-TLF}{m}{rm}#1}}

\thesissetup{
	date        = \the\year/\the\month/\the\day,
	university  = mu,
	faculty     = fi,
	type        = bc,
	author      = Pavel Šimovec,
	gender      = m,
	advisor     = {doc. RNDr. Jan Strejček, Ph.D.},
	title       = {Transformation of Nondeterministic Büchi Automata to Slim Automata},
	TeXtitle    = {Transformation of Nondeterministic Büchi Automata to Slim Automata},
	keywords    = {slim automata, Büchi Automata, GFM-automata, Seminator},
	TeXkeywords = {slim automata, Büchi Automata, GFM-automata, Seminator},
	abstract    = {%
		The thesis describes \emph{slim Büchi good for Markov decision processes automata} construction and extends it for \emph{generalized Büchi Automata}. The construction is implemented in a tool called \emph{Seminator}. Slim automata constructed by Seminator are compared to other automata produced by different tools. The tools are compared by number of states, construction time and learning speed when used for reinforcement learning in \emph{Mungojerrie} tool.
	},
	thanks      = {%
		I would like to thank František Blahoudek for bringing up the topic. I would also like to thank František Blahoudek and Jan Strejček for help with writing the thesis.
	},
	bib         = {exampl.bib},
	%% Uncomment the following line (by removing the %% at the
	%% beginning) and replace `assignment.pdf` with the filename
	%% of your scanned thesis assignment.
	%%    assignment         = assignment.pdf,
}

%%\usepackage{amsmath}


\usepackage{makeidx}      %% The `makeidx` package contains
\makeindex                %% helper commands for index typesetting.
%% These additional packages are used within the document:
\usepackage{paralist} %% Compact list environments
\usepackage{amsmath}  %% Mathematics
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{url}      %% Hyperlinks
\usepackage{markdown} %% Lightweight markup
\usepackage{tabularx} %% Tables
\usepackage{tabu}
\usepackage{booktabs}
\usepackage{listings} %% Source code highlighting
\usepackage{emoji}
\usepackage{cancel}
\usepackage{hhline}
\usepackage{listings}

\usepackage[                % Appendices
toc,page
]{appendix}

\usepackage{tikz}
\usepackage{pgfplots}
\usetikzlibrary{myautomata}
\input{commands.tex}

\lstset{
	basicstyle      = \ttfamily,
	identifierstyle = \color{black},
	keywordstyle    = \color{blue},
	keywordstyle    = {[2]\color{cyan}},
	keywordstyle    = {[3]\color{olive}},
	stringstyle     = \color{teal},
	commentstyle    = \itshape\color{magenta},
	breaklines      = true,
}
\usepackage{floatrow} %% Putting captions above tables
\floatsetup[table]{capposition=top}

%% Calligraphy
\newcommand{\cA}{\mathcal{A}}
\newcommand{\cD}{\mathcal{D}}
\newcommand{\cN}{\mathcal{N}}
\newcommand{\cS}{\mathcal{S}}
\newcommand{\cT}{\mathcal{T}}

\newcommand{\lA}{L(\cA)}
\newcommand{\lD}{L(\cD)}
\newcommand{\lS}{L(\cS)}

%\newcommand{\eqdef}{\overset{\mathrm{def}}{=\joinrel=}}
\newcommand{\eqdef}{\overset{def}{=}}

\newcommand{\flushed}{\text{\emoji{flushed}}}
\newcommand{\hell}{\text{\emoji{fire}}}
\newcommand{\heaven}{\text{\emoji{innocent}}}

\newcommand{\hlineny}{\hline}

\begin{document}
	\chapter{Introduction}
	Büchi automaton is a finite machine over infinite words. It has been a topic of research for almost 60 years.
	There were discovered various kinds of similar machines with different properties and use cases.
	Non-deterministic Büchi automata in general are not well suitable for model checking or reinforcement learning, but we can construct non-deterministic Büchi automata with a special property -- good for Markov decision processes (GFM)  \cite{hlavni}, that makes the automata suitable. We will focus on slim automata \cite{hlavni}.
	Slim automata are specially constructed Büchi automata. This kind of automaton was defined by its construction and is good for MDP \cite{hlavni}. We implement the proposed algorithm and its second variant that we call weak [source private conversation]. We introduce the algorithm for generalized Büchi automata. Then we evaluate resulting size of automata and we compare it with different tool to create slim automata and with other kinds of automata. In the end we investigate impact of slim automata from Seminator on reinforcement against GFM automata created by other tools.
	
	Preliminaries chapter defines Büchi automaton and generalized Büchi automaton. Next chapter defines breakpoint automaton and slim automaton as described in our main source \cite{hlavni} and the weak variant. In fourth chapter we extend the algorithm to generalized Büchi automata. Fifth chapter describes implementation of mentioned slim automata inside Seminator \cite{Klokočka2017thesis}\cite{seminator}\cite{seminator2} tool. In sixth chapter we compare resulting automata size (number of states). First we compare the size internally among implemented options. Then we compare it with ePMC \cite{epmc} - another tool implementing slim automata. We finish the chapter by comparisons with different kinds of automata. In the last chapter we use our automata in benchmarks of reinforcement learning tool Mungojerrie\cite{mungojerrie} and we compare learning speed on it with original automata in provided benchmarks with original benchmark automata and 2 types of automata internally supported by Mungojerrie (slim automata by ePMC and Limit-deterministic Büchi automata by ltl2ldba \cite{ltl2ldba}).
	
	

	\chapter{Preliminaries}
		This chapter defines a Büchi automaton and a generalized Büchi automaton. 
		
		
		An \emph{alphabet} $\Sigma$  is a finite set of \emph{letters}, an \emph{$\omega$-word} $w \in \Sigma^\omega$ is an infinite sequence of letters, and an \emph{$\omega$-language} $L \subseteq \Sigma^\omega$ is a set of $\omega$-words.
		\section{Büchi Automaton} \label{section:tba}
			A Büchi automaton is a theoretical finite-state machine used to define $\omega$-languages. It decides which infinite words ($\omega$-words) belong to its language.
			
			A \emph{transition-based Büchi automaton (TBA)} is a tuple $\cA\eqdef(\Sigma, Q, q_i, \Delta, \Gamma)$, where 
			\begin{itemize}
				\item $\Sigma$ is a non-empty finite \emph{alphabet},
				\item $Q$ is a non-empty finite set of \emph{states},
				\item $q_i \in Q$ is the initial state of $\cA$.
				\item $\Delta \subseteq Q \times \Sigma \times Q$ is a set of \emph{transitions}. 
				\item $\Gamma \subseteq \Delta$ is a set of \emph{accepting transitions}.
			\end{itemize}
			 Intuitivelly, a transition $(s, a, t)$  directionally connects the states $s$ and $t$ with the letter $a$.
			 
			 By convention, we use capital greek letters to denote sets of transitions. For convenience, we also define for each set of transitions $\Delta$ a function $\delta$ (denoted by the corresponding small greek letter).  We define the function  	
			 $\delta\colon (q,a)\eqdef\{q'\in Q \mid  (q,a,q') \in \Delta \land q \in Q\}$. $\Delta$ can be defined by $\delta$ when initial state $q_i$ is defined.
			 
			A \emph{run} $r$ of $\cA$ over an $\omega$-word $w=w_0w_1w_2\ldots$ is an infinite sequence of transitions
			$r\eqdef t_0t_1\ldots\in\Delta^\omega$, where $t_k=(q_k, w_k,q_{i+1})$,
			 such that $q_0=q_i$.
			A run of $\cA$ is \emph{accepting} if and only if it contains infinitely many accepting transitions from $\Gamma$.

			Finally, we define the \emph{language} $\lA \subseteq \Sigma^\omega$ recognized by the automaton $\cA$. An $\omega$-word $w \in \Sigma^\omega$ belongs to $\lA$ if and only if there exists an accepting run of $\cA$ over the word $w$. 
			
			
		\section{Generalized Büchi Automaton}
		A \emph{transition-based Generalized Büchi automaton} (TGBA) is a tuple $\cA\eqdef(\Sigma, Q, q_i, \Delta, G)$, where $G \subseteq 2^\Delta$ contains sets of accepting conditions and the rest is defined as for TBA. A run of $\cA$ is \emph{accepting} iff it contains infinitely many accepting transitions \emph{for each} $\Gamma \in G$. TBA can be seen as a special case of TGBA with $|G|=1$.
		
		
			
			
			
	\chapter{Slim Automata Construction}
			
			%%todle mozna trochu jinak v (ne dalsi ale) teto sekci
			%%We are going to define a few more transitions on top of breakpoint construction which allow us to construct slim automata that decide exactly the class of <GFM languages> spatny pojem. jsou to omega regularni
			
			%Breakpoint automata constructed as presented in the previous section are not always equivalent to the input automaton, but are deterministic. Slim automata are equivalent to do not hold the deterministic property, however they are GFM\footnote{Good for Markov decision processes [+zdroj]}
			
			
			
			
			
			
			
			
			This chapter defines \emph{slim Büchi automaton} (slim automaton) in 2 variants - \emph{strong} and \emph{weak}. Slim automaton is defined through its construction, which is based on breakpoint construction. 
			
			\section{Breakpoint Automaton} \label{section:bp}
			
			 BP automata are constructed from BA and are deterministic, but their language is only a subset of the language from original BA. 
			
			\paragraph{Construction}
			Let us fix a Büchi Automaton $\cA\eqdef(\Sigma, Q, q_i, \Delta, \Gamma)$. 
			
			%%We want to construct a deterministic automaton $\cD$ such that $\lD\subseteq \lA$ 
			We start with some notation. By $3^Q$ we denote the set $\{(S,S') \mid S'\subsetneq S \subseteq Q\}$ and
			by $3^Q_+$ we denote $\{(S,S') \mid S'\subseteq S \subseteq Q\}$.
			
			%%We define the notation for the transitions and accepting transitions as $\delta,\gamma:2^Q \times \Sigma \rightarrow 2^Q$ with
			
			For convenience we introduce functions by sets of transitions, we define the function $\delta \colon 2^Q \times \Sigma \rightarrow 2^Q$ as 	
			$\delta\colon (S,a)\eqdef\{q'\in Q \mid  (q,a,q') \in \Delta \land q \in S\}$.
			%%\exists q \in S.(q,a,q') \in \Delta\}$.
			We define $\gamma:2^Q  \times \Sigma \rightarrow 2^Q$ analogously from $\Gamma$ as $\gamma\colon (S,a)\eqdef\{q'\in Q \mid  (q,a,q') \in \Gamma \land q \in S\}$.
			
			%%$\gamma: (S,a)\eqdef\{q'\in Q \mid \exists q \in S.(q,a,q') \in \Gamma\}$
			
			With $\delta$ and $\gamma$, we define the raw breakpoint transition
			$\rho_\Gamma \colon 3^Q \times \Sigma \rightarrow 3^Q_+$ as
			\[\rho_\Gamma((S, S'), a) \eqdef(\delta(S, a), \delta(S',a)\cup \gamma(S, a))\]
			The first set follows the set of reachable states in the first set and the states that are reachable while passing at least one of the accepting transitions in the second set.
			The transitions of the breakpoint automaton $\cD$ follow $\rho$ with an exception: they reset the second set to the empty set when it equals the first; the resetting transitions are accepting.
			Formally, the breakpoint automaton $\cD$ is $ \eqdef (\Sigma, 3^Q, (q_i, \emptyset), \Delta_D, \Gamma_D)$ where $\Delta_D$ and $\Gamma_D$ are defined as follows. 
			
			\begin{enumerate}
				\item $((S, S'), a, (R, R')) \in \Delta_D$ if $\rho_\Gamma((S,S'),a)=(R,R')$ where $R' \subsetneq R$
				\item \label{reset}$((S, S'), a, (R, \emptyset)) \in \Delta_D$ and $((S, S'), a, (R, \emptyset)) \in \Gamma_D$ if $\rho_\Gamma((S,S'),a)=(R,R)$ 
				\item No other transitions are in $\Delta_D$ and $\Gamma_D$
			\end{enumerate}
			
			%%Breakpoint automata recognize/describe/represent subset of original language 
			Figure \ref{fig:bp:non-equivalent} shows application of this construction. The example demonstrates that $\lD \subseteq \lA$ as the construction did not generate any accepting transition. Therefore original $\lA=\{a^\omega\}$, but $\lD$ is empty. 
			
			
			
			\begin{figure}[ht]
				\begin{center}
					\input{bp.tikz}
					
				\end{center}
				\caption{A Büchi Automaton $\cA$ (left) and a breakpoint automaton $\cD$ for $\cA$ (right). Inspired by \cite[Figure~7.3]{Blahoudek2018thesis}}
				\label{fig:bp:non-equivalent}
			\end{figure}
		
			\section{Slim automata}\label{section:slim}
			Slim automata are BP automata enriched with additional transitions. As a result they are non-deterministic, Good for Markov decision processes \cite{hlavni} and equivalent to the input automata.	
			In this section we define transition function for \emph{strong slim} ($\gamma_{p}$)\cite{hlavni} and \emph{weak slim} ($\gamma_{w}$) automata,
			 $\gamma_w, \gamma_p:3^Q \times \Sigma \rightarrow 3^Q$, that promote the second set of a breakpoint construction to the first set as follows. 
			
			\begin{enumerate}
				\item if $\delta(S',a) = \gamma(S, a) = \emptyset$, then $\gamma_{p}((S,S'), a)$ and $\gamma_{w}((S,S'), a)$ are undefined, and
				\item otherwise
				$\gamma_{p}:((S,S'),a)=(\delta(S',a)\cup\gamma(S, a),\emptyset)$ and $\gamma_{w}:((S,S'),a)=(\delta(S',a),\emptyset)$
			\end{enumerate}
			
			
			$\cS\eqdef(\Sigma, 3^Q, (q_i,\emptyset), \Delta_S ,\Gamma_S)$ is (strong) slim, when  $\Gamma_p$ is generated by $\gamma_p$, then 
			$\Delta_S=\Delta_D \cup \Gamma_p$ is set of transitions, and
			$\Gamma_S=\Gamma_D \cup \Gamma_p$ is set of accepting transitions. $\lS = \lA$. The equivalence was proven in \cite{hlavni}.
			
			Alternatively, similarly defined using $\gamma_w$ instead of $\gamma_{p}$, automaton $\mathcal{W}\eqdef(\Sigma, 3^Q, (q_i,\emptyset), \Delta_W, \Gamma_W)$ is (weak) slim  when $\Gamma_w$ is generated by $\gamma_w$, then 
			$\Delta_W=\Delta_D \cup \Gamma_w$ is set of transitions, and
			$\Gamma_W=\Gamma_D \cup \Gamma_w$ is set of accepting transitions. $L(\mathcal{W}) = \lA$  (proof would go similarly like the one for strong slim).
			
			\begin{figure}[ht]
				\begin{center}
				\input{slim.tikz}
				\end{center}
				\caption{Slim automaton (right) and the original Büchi automaton from Figure \ref{fig:bp:non-equivalent}(left).  The image highlights underlying breapoint construction by green color (as in Figure~\ref{fig:bp:non-equivalent}). A blue transition is created only by strong slim transitions. State and transition  highlighted by red color would be created directly by both weak and slim transitions.  Let us note that state $\{\{\heaven\},\{\heaven\}\}$ is not part of produced automaton. It visualizes reset from breakpoint construction, step~\ref{reset}, which is applied even when the source state was created by slim transitions. }
				\label{fig:slim:equivalent}
			\end{figure}

			
	\chapter{Slim Automaton Construction Generalized to TGBA} \label{section:gslim}
			In this chapter, we discuss slim automata equivalent to a TGBA $\cT\eqdef(\Sigma, Q, q_i, \Delta, G)$.
			One possibility is to \emph{degeneralize} $\cT$ and to use previously mentioned algorithm in section 2.3.
			In the rest of this chapter we introduce a direct construction of slim TGBA equivalent to $\cT$.
			\paragraph{Extended slim construction}
			Intuitivelly, we will simulate the original automaton by checking its accepting conditions on by one. In the original automaton have to go through an accepting transition of each accepting condition $g \in G=\{G_0, G_1, \ldots, G_k\}$ infinitely many times. In new automaton we have just one accepting condition and a layer for each original accepting condition. Going through original accepting transitions of layer that we are looking up promotes us to another layer. From the last layer we get back to first layer. Only the transitions that move us layer up are accepting. As we check all accepting conditions of the original automaton, the new automaton will be equivalent to the original one. We will use word "levels" instead of layers in following definitions.
			
			
			We need to make sure we go infinitely many times trough each accepting subset $g \in G$.
			To achieve this, we will go through each subset one by one, using original algorithm. We will keep track of $levels=\{0,1,\ldots,|G|-1\}$ in the names of states. Let $|G|$ be number of $levels$ and $i \in \mathbb{N}, i<|G|$ the current level.
			At each level $i$, we look at $i$th subset of $G$. We use same steps as in classic breakpoint construction, but on each accepting transition the new state will be leveled up to $(i+1)\bmod|G|$, otherwise the target state has the same level. Our new automaton simulates $\cT$, as it accepts a word if it cycles through all levels. If $|G|=0$, we return a trivially accepting automaton
			
			We can use the core of previous construction and just to extend it with levels.
			%$3^Q_i :=\{(S,S',i)|S'\subset S \subseteq Q, i \in N, i<|G|\}$ and
			%$3^Q_{i+}:=\{(S,S',i)|S'\subseteq S \subseteq Q, i \in N, i<|G|\}$.
	
			
			Let $(S,S')\in 3^Q$ and let $i \in levels$, by $P$ we denote a state $P=(S,S',i)$.
			%$\delta: (S,a)\rightarrow\{q'\in Q | \exists q \in S.(q,a,q') \in \Delta\}$ and
			
			%%$\gamma_{iS}: (S,a)\rightarrow\{q'\in Q | \exists q \in S.(q,a,q') \in G_i\}$
			We define $\gamma_i$ from $\Gamma_i$ for all $i \in levels$ in the same way we did for $\gamma$ from $\Gamma$. We use raw breakpoint transitions $\rho_{\Gamma}$ from tba breakpoint construction in Section~\ref{section:bp}.
			
			Let $up(x)=(x+1)\bmod|G|$.
			
			The generalized breakpoint automaton $\cD=(\Sigma, 3^Q\times\cN, ({q_i},\emptyset, 0),\Delta_B,\Gamma_B)$ is defined by breakpoint transitions ($\delta_B$ generates $\Delta_B$ and $\gamma_B$ generates $\Gamma_B$) as follows.
			
			When $\rho_{\Gamma} \colon((S,S'), a) \rightarrow (R, R')$, then for all $i \in levels$:
			
			For breakpoint transitions there are three cases:
			
			\begin{enumerate}
				\item if $R=\emptyset$ , then $\delta_B(P,a)$ is undefined,
				\item else, if $R \neq R'$, then $\delta_B((S,S',i),a) = (R,R',i)$ is a non-accepting transition,
				\item otherwise $\gamma_B(P, a) = \delta_B((S,S',i),a) = (R, \emptyset, up(i))$.
			\end{enumerate}
		
		
			%%	$\gamma_{p}: P \times \Sigma \rightarrow P$
			For slim transitions there are two additional cases:
			\begin{enumerate}
				\item if $\delta(S',a)=\gamma_{i}(S, a)=\emptyset$, then $ \gamma_{p}((S,S',i),a)$ is undefined, and
				\item otherwise $\gamma_p((S,S',i),a) = \gamma_p((S,S',i),a) = (\delta(S',a)\cup \gamma_{i}(S, a), \emptyset, up(i))$. (Alternatively, for a weak slim automaton we do not include transitions $\gamma_{i}(S, a)$)
			\end{enumerate}
			$\cS\eqdef(\Sigma, (S,S',i), (q_i,\emptyset,0), \Delta_S,\Gamma_S))$ is slim, when $\Delta_S=\Delta_B\cup\Delta_p$, generated by $\delta_B$ and $\gamma_p$, and $\Gamma_S=\Gamma_B\cup\Gamma_p$ is set of accepting transitions, that is generated by $\gamma_B$ and $\gamma_p$.
			
						
			\begin{figure}[ht]
				\begin{center}
					\input{tgba.tikz}
					
				\end{center}
				\caption{The original TGBA (top) and slim automaton with colored states emphasizing different levels (bottom).  }
				\label{fig:slim:gg}
			\end{figure}
			

			
	\chapter{Implementation} \label{implementation}
		I have implemented the generalized construction of slim automata in both weak and strong version  (\ref{section:slim}) (\ref{section:gslim}). I have also added option to create breakpoint automata (\ref{section:bp}).
		
		\section{Technologies/Tools}
		The implementation is inside Seminator which is implemented in C++17 builds on Spot library. %\cite{DBLP:conf/mascots/Duret-LutzP04}.
		\subsection{Seminator} 
		Seminator is a Linux command-line tool which can be run with the \texttt{seminator} command. The tool transforms transition-based generalized Büchi automata (TGBAs) into equivalent semi-deterministic automata. \cite{Klokočka2017thesis}\cite{seminator}\cite{seminator2}
		
		
		
		The tool expects the input automaton in the Hanoi Omega-Automata (HOA) format \cite{DBLP:conf/cav/BabiakBDKKM0S15} on the standard input stream, but it can also read the input automaton from a file.
		
	\subsection{Spot}
	"Spot is a C++ library with Python bindings and an assortment of command-line tools designed to manipulate LTL and $\omega$-automata in batch." \cite[Abstract]{spot2}
	
	Relevant spot tools:
	\paragraph{ltl2tgba} "translates LTL/PSL formulas into generalized Büchi automata,or deterministic parity automata" \cite{spot}
	\paragraph{autfilt} "filters, converts, and transforms $\omega$-automata"  \cite{spot}
	\paragraph{ltlcross} "cross-compares LTL/PSL-to-automata translators to find bugs" \cite{spot}
		\section{Create Slim Automata Using Seminator}
		By default, seminator creates sDBA. To create a slim automaton we need to add -{}-slim option. 
		\paragraph{Options} By default, -{}-slim tries all reasonable combinations of options, optimizes the output and chooses an automaton with the smallest number of states.
		
		\paragraph{Example 1}
		Transform automaton.hoa to a slim automaton.

		\begin{lstlisting}[language=bash]
$./seminator --slim -f automaton.hoa
		\end{lstlisting}
		
		There are several options to specify how we construct the automata.
		
		For example \texttt{seminator -{}-slim -{}-strong -{}-optimizations=0 -{}-via-tgba} generates output according to algorithm in \ref{section:slim}. (Using \texttt{-{}-via-tba} converts input to tba first) With automaton
		
		
		\paragraph{Example 2}
		Transform automaton.hoa to unoptimized strong slim automaton
		\begin{lstlisting}[language=bash]
$./seminator --slim --strong --via-tgba --postprocess=0 -f automaton.hoa
		\end{lstlisting}
		
		 
		
		\texttt{-{}-slim }to generate slim automaton
		
		\texttt{-{}-weak} use only weak slim algorithm
		
		\texttt{-{}-strong} use only strong slim algorithm
		
		Neither weak or strong option specified - try both options  and choose the one with smaller automaton.
		
		\texttt{-{}-via-tba} transform input automaton to tba \ref{section:tba} first
		
		\texttt{-{}-via-tgba} does not modify input automaton to tba.
		
		Neither \texttt{-{}-via-tba} nor \texttt{-{}-via-tgba}: try both options, choose the smallest automaton.
		
		Postprocess optimalizations are enabled by default.
		
		
	\section{Implementation of Slim Automata inside Seminator}
	I have implemented the generalized slim construction and its options mentioned in previous section. Furthermore, I have added an option to create breakpoint automata.
	
	There already was basis for breakpoint construction in seminator, inside class \texttt{bp\_twa}.
	As we can see in sections \ref{section:bp} and \ref{section:slim}, slim automata construction builds on breakpoint automata construction.
	
	That allows us to simply extend the \texttt{bp\_twa} class.
	We create class \texttt{slim} that inherits from \texttt{bp\_twa}.
	In the \texttt{slim} class we build breakpoint automaton using \texttt{compute\_successors} method.
	Then we extend the method by adding accepting transitions $\gamma_p$, respectively $\gamma_w$ according to section \ref{section:gslim}, whenever we receive \texttt{-{}-slim} option.
	
	Then we extend main function to recognize our desired CLI options.
	
	As Seminator didn't offer a command line option to create a breakpoint automaton, I have added the option \texttt{-{}-bp} for comparison.
	
	
	
	\section{Testing and Verification}
	Implemented tests are basic, only language equivalence is checked.
	ltlcross and ltl2tgba tools are used. The tests use random LTL formulas that were already generated, the LTL formulas are transformed into automata in HOA format by ltl2tgba.
	Then the tool ltlcross cross-compares the automaton with \emph{seminator -{}-slim} with all supported additional parameters.
	
	Only \texttt{seminator -{}-slim -{}-strong -{}-via-tba -{}-optimizations=0} is proved, as it follows construction from \cite{hlavni} which is proved.
	
	\section{Future of Implementation}
	Implementation:
	Optimizations of slim construction (especially from TGBA).
	
	
	
	Tests/verification:
	There should be another kind of tests - to check if our slim automata simulate the input automata, so the GFM property is not broken.
	
	Subject of following research, that is out of scope of this thesis, could be to verify if Spot's optimizations do not break the simulation property. 
	
	\chapter{Evaluation of automaton size}
	Evaluation part builds on seminator-evaluation. We compare amount of states of output automata on 2 datasets. First dataset are 20 literature formulas, second dataset is 500 automata that were randomly generated. We use 120s timeout for each tool. First section starts by internal comparison of slim automata created by Seminator. Second section compares these automata against ePMC, which is another tool producing slim automata. Third section compares slim automata against ldba and semi-deterministic automata. Ldba automata are produced by ltl2ldba \cite{ltl2ldba}, and semi-deterministic automata are produced by Seminator. Let us note, that from mentioned types of automata, only semi-deterministic automata do not promise good for Markov decision processes property.
	
	\section{Slim automata produced by Seminator}
	In this section we compare automaton size generated by \texttt{seminator --slim}.
	We compare weak against slim and via-tba against via-tgba.
	\subsection{Comparisons among Unoptimized Configurations}
	In this subsection we compare base unoptimized seminator options.
	
	In Table~\ref{table:seminator:unoptimized} strong slim automata have more states than weak ones, as expected, because strong slim automata add more accepting transitions, which can create new states. Transforming automata to TBA first yields smaller automata. This might be caused by Spot having well optimized algorithm for degeneralization. Slim algorithm for TGBA proposed in this paper is naive, without any kind of optimizations, and it degeneralizes the automaton during the process.
\begin{table}[ht]
	\label{table:seminator:unoptimized}
	\centering
	\caption{Slim automata on both datasets without any post-processing (no timeouts).}
		\begin{tabular}{ |c||c|c|c|c| } 
			\hline
			seminator&\multicolumn{2}{c|}{weak}&\multicolumn{2}{c|}{strong} \\
			\hline
			literature&size&time(s)&size&time(s)\\
			\hhline{|=====|}
			
			via tba	&	1095	&4	& 1112 	&5\\
			\hline
			via tgba&	1122	&4		&1147	&4\\ 
			\hline
			\hline
			\hline
			seminator&\multicolumn{2}{c|}{weak}&\multicolumn{2}{c|}{strong} \\
			\hhline{|=====|}
			random&size&time(s)&size&time(s)\\
			\hline
			via tba&17567&	59& 18764 &57\\
			\hline
			via tgba&19320&	58& 20789&58\\ 
			\hline
		\end{tabular}
\end{table}
	\clearpage
	\subsection{Post-Optimized}
	In this subsection we post-optimize results using \texttt{autfilt} tool.
	
	GFM automata are closed under simulations \cite[Section~3.1]{hlavni}. We are confident that spot's \texttt{autfilt} does not break the property.
	
	\begin{table}[ht]
		
		\centering
		\caption{In this table we compare all possible post-optimized combinations of parameters. By default \texttt{seminator --slim} tries all combination, runs optimizations, and then chooses the smallest automaton (best/best). }
		\label{table:seminator:optimized}
		\begin{tabular}{ |c||c|c|c|c|c|c| } 
			\hline
			seminator&\multicolumn{2}{c|}{weak}&\multicolumn{2}{c|}{strong}&\multicolumn{2}{c|}{best} \\
			\hline
			literature&size&time[s]&size&time[s]&size&time[s]\\
			\hhline{|=======|}
			
			via tba&551&219& 370 &185& 370&404\\
			\hline
			via tgba&588&210& 408&174& 402&384\\ 
			\hline
			best&551&429& 370&359& 365&788 \\ 
			\hline
			
			
			\hline
			seminator&\multicolumn{2}{c|}{weak}&\multicolumn{2}{c|}{strong}&\multicolumn{2}{c|}{best} \\
			\hline
			random&size&time[s]&size&time[s]&size&time[s]\\
			\hhline{|=======|}
			via tba&8923&443& 7404 &476& 7219&919\\
			\hline
			via tgba&10130&654& 8500&591& 8247&1245\\ 
			\hline
			best&8751&1097& 7285&1067& 7088&2164 \\ 
			\hline
		\end{tabular}
	\end{table}

	
	As Table \ref{table:seminator:optimized} shows, from 4 base options; after applying post-optimizations strong slim algorithm surpasses weak one by resulting automaton size, even if it has worse results without the post-optimizations.
	Degeneralizing the automata as a first step still has smaller results.
	From 4 base options, strong slim algorithm via-tba creates smallest automata on average.
	Transforming input automata to tba first creates results which are close to best ones. 
	
	
	\paragraph{Strong against weak slim automata}
	Let us focus on automaton size differences between weak and strong slim automata.
	
	Scatter plot~\ref{scatter:weakstrong} reveals that strong slim automaton is smaller in majority of cases, but there are also cases where weak slim automaton is smaller.
		\begin{figure}[ht]
			
			\centering 
			\caption{Scatter plot of strong against weak slim automata, equal values excluded. }
			\label{scatter:weakstrong}
		\begin{tikzpicture}
			\input{scatter/strong-weak.tikz}
		\end{tikzpicture}
	\end{figure}
	
		Comparing minimal hits for weak and strong automata in Table~\ref{table:weakstrongminhits} confirms that strong slim automata lead in unique minimal hits, but weak slim automata have some unique minimal hits too, so it makes sense to try both options and choose better one. 
		\begin{table}[ht]
			\centering
			
			\caption{Minimal hits of strong and weak slim automata.}
			\label{table:weakstrongminhits}
			\begin{tabular}{ |c||c|c| } 
				\hline
				literature&unique minimal hits&minimal hits\\
				\hhline{|===|}
				weak&4 & 9\\
				\hline
				strong&11 & 16\\ 
				\hline
				\hline
				random&unique minimal hits&minimal hits\\
				\hhline{|===|}
				weak&68 & 202\\
				\hline
				strong&296 & 430\\ 
				\hline
			\end{tabular}
		\end{table}

		\paragraph{Via-tba against via-tgba}
		Let us note that 13/20 formulas from literature and 391/500 formulas from random dataset create automata that are already TBA.
		
		Plot~\ref{scatter:tba-tgba} density is low, as many of results are the same (majority of the automata were already tba). Via-tba has mostly better results, but there are examples where via-tgba outputs automaton twice smaller automaton. Table~\ref{table:tba-tgba-min-hits} confirms that via-tba has better results. Via-tgba has only 9 minimal hits compared to 91 from via-tba.
		
		\begin{figure}[ht]
			\centering
			
		\caption{Scatter plot via-tba against via-tgba, equal values excluded. }
		\label{scatter:tba-tgba}
		\begin{tikzpicture}
			\input{scatter/tba-tgba.tikz}
		\end{tikzpicture}
		\end{figure}
		
		 
		\begin{table}[ht]
			
			\centering
			\caption{Minimal hits of via-tba against via-tgba.}
			\label{table:tba-tgba-min-hits}
			\begin{tabular}{ |c||c|c| } 
				\hline
				literature&unique minimal hits&minimal hits\\
				\hhline{|===|}
				via-tba&7 & 20\\
				\hline
				via-tgba&0 & 13\\ 
				\hline
				\hline
				random&unique minimal hits&minimal hits\\
				\hhline{|===|}
				via-tba&91 & 489\\
				\hline
				via-tgba&9 & 407\\ 
				\hline
			\end{tabular}
		\end{table}
	\clearpage
		\section{Slim Automata Produced Seminator versus ePMC}
		We can create slim automata using different tool called ePMC.
		
		At first we compare best working basic paramaters (parameters that try only 1 option) of each tool to create smallest automata to obtain fair time comparison.
		As Table~\ref{table:epmc-seminator-1} shows, Seminator creates smaller automata and faster. In Figure~\ref{scatter:slim-epmc-1} we can see, that ePMC has some better hits.
	
	\begin{table}[ht]
		\centering
		
		\caption{EPMC acc stands for option, that uses accepting transitions whenever possible. It had slightly better results than other ePMC options. 120s timeouts are included in total time, however sum of automaton size is computed only from automata that were successfully created by both tools. }
		\label{table:epmc-seminator-1}
		\begin{tabular}{ |c||c|c|c| } 
			\hline
			literature&size&time[s]&timeouts\\
			\hhline{|====|}
			ePMC acc&650 &178&0 \\
			\hline
			Seminator tba strong &436 &151&0 \\
			\hlineny
			\hline
			random&size&time[s]&timeouts\\
			\hhline{|====|}
			ePMC acc&9643 & 5146&8\\
			\hline
			Seminator tba strong &7032 &405&2 \\
			\hlineny
		\end{tabular}
	\end{table}
	\begin{figure}[ht]
		\centering
		
		\caption{Scatter plot comparing sizes of ePMC acc and Seminator tba strong.}
		\label{scatter:slim-epmc-1}
		\begin{tikzpicture}
			\input{scatter/slim-epmc-1-option.tikz}
		\end{tikzpicture}
	\end{figure}
	
	
		The section compares smallest automata of each tool to see how smaller automata get by combining these tools.
		
		As Figure~\ref{scatter:slim-epmc} shows, Seminator slim has most of the best results and the difference is even bigger than single option comparison in Figure~\ref{scatter:slim-epmc-1}. Combining Seminator and ePMC for best automata didn't bring much better results. On random dataset total size of automata from Seminator slim is 7133. If we combine Seminator slim and ePMC, we get total size 7060, which is not that significant difference.
	
\begin{figure}[ht]
	\centering
	
	\caption{Scatter plot comparing smallest optimized automata generated by each tool. }
	\label{scatter:slim-epmc}
	\begin{tikzpicture}
		\input{scatter/slim-epmc.tikz}
	\end{tikzpicture}
\end{figure}
Then this section continues with comparison of minimal hits. Table~\ref{table:epmc-seminator-min-hits} shows that by unique minimal hits of these tool ePMC has 35 unique minimal hits compared to 344 of Seminator. But as we can see from previous scatter plot \ref{scatter:slim-epmc}, the size difference isn't that high.
\begin{table}[ht]
	\centering
	
	\caption{Comparison showing how many times tool got smallest or uniquely smallest automata.}
	\label{table:epmc-seminator-min-hits}
	\begin{tabular}{ |c||c|c| } 
		\hline
		literature&unique minimal hits&minimal hits\\
		\hhline{|===|}
		ePMC&1 & 5\\
		\hline
		Seminator &15 & 19\\ 
		\hline
		\hline
		random&unique minimal hits&minimal hits\\
		\hhline{|===|}
		ePMC&35 & 155\\
		\hline
		Seminator &344 & 464\\ 
		\hline
	\end{tabular}
\end{table}
		
	
	
	
		%%\subsection{Comparisons among Unoptimized options}
		%%\subsection{Comparisons among Post-Optimized options}
		
		
		%%\section{via tba/no change}
		%%\subsection{Comparisons among Unoptimized options}
		%%\subsection{Comparisons among Post-Optimized options}

		%\section{Slim automata produced seminator ePMC}
	\clearpage
		\section{Compare with Different Kinds of Automata}
		This section brings size comparison with diffent kinds of automata. It compares slim automata with ltl2ldba \cite{ltl2ldba}, default automata created by Seminator (semi-deterministic), and ePMC \cite{epmc}.
		
		Results of table~\ref{table:basic-tools} show that semi-deterministic automata created by Seminator are the smallest on average among the compared tools. Ltl2ldba creates the smallest GFM automata, as semi-deterministic automata do not promise GFM property.
		
		\begin{table}[ht]
			\centering
			
			\caption{Automata sizes after applying Spot's optimizations.}
			\label{table:basic-tools}
			\input{tables/basic-tools.tex}
		\end{table}
		
		
		
		Now we compare \texttt{seminator --slim} with other tools using scatter plots.
		
		Figure~\ref{scatter:seminator-slim-default} shows that semi-deterministic automata are consistently smaller or just slightly bigger than slim automata. 
		As Figure~\ref{scatter:seminator-ltl2ldba} shows, ltl2ldba creates consistently small automata (smaller than 40 states), however its dominance over slim automata is not that consistent. The plot shows we can create reasonably smaller MDP automata on average using both tools and choosing the smallest automaton. Table~\ref{table:basic-tools-mix} confirms that. For literature dataset the mixed tool even beats semi-deterministic automata from Seminator.
		\begin{figure}[ht]
			\centering
			
			\caption{Comparison of semi-deterministic and slim automata created by Seminator.}
			\label{scatter:seminator-slim-default}
			\begin{tikzpicture}
				\input{scatter/slim-sem_def.tikz}
			\end{tikzpicture}
		\end{figure}
		
		\clearpage
		\begin{figure}[ht]
			\centering
			
			\caption{Slim automata from Seminator against automata from ltl2ldba.}
			\label{scatter:seminator-ltl2ldba}
		\begin{tikzpicture}
		\input{scatter/slim-ltl2ldba.tikz}
		\end{tikzpicture}
		\end{figure}
	
	\begin{table}[ht]
		\centering
		
		\caption{Automaton size comparison of Seminator slim + ltl2ldba combined tool against other tools.}
		\label{table:basic-tools-mix}
		\input{tables/basic-tools-mix.tex}
	\end{table}

	\chapter{Mungojerrie Benchmarks}
	This chapter compares Seminator's slim automata on reinforcement learning tool Mungojerrie \cite{mungojerrie}. Reinforcement learning inside Mungojerrie has 2 phases. It has a learning phase with given number of episodes and a model checking phase. The objective is defined by provided GFM automaton.\cite{mungojerrie}
	
	
	The experiment uses benchmarks provided with the tool - Examples. Automata for examples are built by various ways, some can be even handcrafted. Using LTL, that is provided as a name of automaton in each original benchmark, we create slim automata for comparison on benchmarks, as Mungojerrie can accept LTL and transform it using internally supported tools ltl2ldba and ePMC, or we can provide automaton that is GFM (the property is not checked by Mungojerrie).
	
	
	Experiments are searching for lowest necessary amount of episodes needed for reaching probability 1 to hit the objective in model checking phase. Experiments run benchmarks 10 times with pseudo random seeds 0-9. If all runs ends with success, experiment computes median and average of results. A run can fail by timeout (600s) or by not reaching probability 1. We exclude uninteresting benchmarks, where all tools achieve the same result. 
	
	Table~\ref{Table:mungostats}.1 shows that ltl2ldba has unique best results most often, but Seminator slim has some best hits too.
	
	Examples have unclear origins, therefore Table~\ref{Table:mungostatsnoex}.2 shows the results without the Examples. Ltl2ldba still has the best unique results most often, but Seminator gets closer to ltl2ldba. Compared to previous table, Seminator has now more best averages and medians than ltl2ldba. The table also shows ePMC having higher amount of second best averages and medians than other tools. 
	
	Table~\ref{Table:mungobenchmarks}.3 contains average episodes needed for benchmark for each tool. It is visualized by cactus plot on Figure~\ref{Cactus:mungoaverage}.1. There we can see, that ends of lines match number of failures in tables~\ref{Table:mungostats}.1, \ref{Table:mungostatsnoex}.2.
	
	Figure~\ref{Cactus:mungoruns}.2 shows cactus plot of all benchmark runs. There we can observe, that Seminator has the highest number of succesful runs, therefore the lowest number of failures. It doesn't match the plot Figure~\ref{Cactus:mungoaverage}.1. The reasoning follows: Looking at number of failures on Table~\ref{Table:mungostatsnoex}.2, both ePMC and ltl2ldba have 1 benchmark, which fails on all of its runs. Seminator has 2 benchmarks, which fail only on 1 run (by not achieving probability 1). Therefore Seminator succeeds at more runs than other tools in Figure~\ref{Cactus:mungoruns}.2.
	
	
	
	\begin{table}[ht]
		\centering
		\label{Table:mungostats}
		\caption{Results with Examples included}
		\input{mungostats.tex}
	\end{table}
	
	\begin{table}[ht]
		\centering
		\label{Table:mungostatsnoex}
		\caption{Results with Examples excluded }
		\input{tables/stats-noexamples.tex}
	\end{table}
	
	\begin{table}[ht]
		\centering
		\label{Table:mungobenchmarks}
		\caption{Table of average episodes needed to reach probability 1.}
		\input{mungobench.tex}
	\end{table}
	
	\begin{figure}[ht]
		\centering
		\label{Cactus:mungoaverage}
		\caption{Sorted values for benchmark's average run for each tool by number of episodes (y-axis). Number of benchmarks is on x-axis. }
		\input{cactuses/average.tikz}
	\end{figure}
	\begin{figure}
		\centering
		\label{Cactus:mungoruns}
		\caption{Sorted values for all of benchmark runs for each tool by number of episodes (y-axis). Number of benchmark runs is on x-axis. }
	\input{mungocactus.tikz}
	\end{figure}
	
	\chapter{Conclusions}
	
	I have described slim automata with its prerequisities (based on \cite{hlavni}) and its weak version.
	I have extended the construction to input TGBA automata.
	I have also implemented the construction of slim automata inside Seminator, which was the main goal.
	Then I have compared automaton size of slim automata and different tools.
	I have ended up with evaluating performance of Seminator's slim automata on recently released Mungojerrie tool.
	
	\begin{appendices}
	
	\chapter{List of Electronic Attachments}
	As part of thesis, I have also submitted the following electronic attachment:
	
	\texttt{seminator.zip} - Seminator which is released under the GNU GPL v3.0 license, extended by implementation of slim automata as described in Chapter~\ref{implementation}.
	\end{appendices}
\end{document}