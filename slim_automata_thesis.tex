\documentclass[
	digital
nolof, nolot
]{fithesis3}

\usepackage{paratype}
\def\textrussian#1{{\usefont{T2A}{PTSerif-TLF}{m}{rm}#1}}

\thesissetup{
	date        = \the\year/\the\month/\the\day,
	university  = mu,
	faculty     = fi,
	type        = bc,
	author      = Pavel Šimovec,
	gender      = m,
	advisor     = {RNDr. František Blahoudek, Ph.D.; doc. RNDr. Jan Strejček, Ph.D.},
	title       = {Transformation of Nondeterministic Büchi Automata to Slim Automata},
	TeXtitle    = {Transformation of Nondeterministic Büchi Automata to Slim Automata},
	keywords    = {keyword1, keyword2, ...},
	TeXkeywords = {keyword1, keyword2, \ldots},
	abstract    = {%
		abstract
	},
	thanks      = {%
		ack
	},
	bib         = example.bib,
	%% Uncomment the following line (by removing the %% at the
	%% beginning) and replace `assignment.pdf` with the filename
	%% of your scanned thesis assignment.
	%%    assignment         = assignment.pdf,
}

%%\usepackage{amsmath}


\usepackage{makeidx}      %% The `makeidx` package contains
\makeindex                %% helper commands for index typesetting.
%% These additional packages are used within the document:
\usepackage{paralist} %% Compact list environments
\usepackage{amsmath}  %% Mathematics
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{url}      %% Hyperlinks
\usepackage{markdown} %% Lightweight markup
\usepackage{tabularx} %% Tables
\usepackage{tabu}
\usepackage{booktabs}
\usepackage{listings} %% Source code highlighting

\usepackage{cancel}

\lstset{
	basicstyle      = \ttfamily,
	identifierstyle = \color{black},
	keywordstyle    = \color{blue},
	keywordstyle    = {[2]\color{cyan}},
	keywordstyle    = {[3]\color{olive}},
	stringstyle     = \color{teal},
	commentstyle    = \itshape\color{magenta},
	breaklines      = true,
}
\usepackage{floatrow} %% Putting captions above tables
\floatsetup[table]{capposition=top}

\begin{document}
	\chapter{Introduction}
	\chapter{Preliminaries}
		In this section we define a Büchi automaton, as slim automata are specially constructed Büchi automata.
		\section{Büchi Automaton}
			A Büchi automaton is a theoretical finite-state machine used to define $\omega$-languages. It decides which infinitely long words ($\omega$-words) belong to its language.
			
			A \emph{transition-based Büchi automaton (TBA)} is a quintuple $A=(\Sigma, Q, q_i, \Delta, \Gamma)$, where 
			\begin{itemize}
				\item $\Sigma$ is a finite \emph{alphabet},
				\item $Q$ is a finite set of \emph{states},
				\item $q_0 \in Q$ is the initial state of $A$.
				\item We write the set of \emph{transitions} as $\Delta \subseteq Q \times \Sigma \times Q$. Intuitivelly, a transition $(s, a, t)$  directionally connects two states inside $Q$ with a letter from alphabet $\Sigma$. 
				\item $\Gamma \subseteq \Delta$ is a set of \emph{accepting transitions}.
			\end{itemize}

			 An \emph{alphabet} is a set of letters. An \emph{$\omega$-word} $w \in \Sigma^\omega$ is an infinite sequence of letters. A \emph{language} is a set of $\omega$-words.
			
			A \emph{run} $r$ of $A$ is an infinite sequence of transitions
			$r=(q_0, a_0, q_1)(q_1, a_1, q_2)(q_2, a_2, q_3)\ldots\in\Delta^\omega$ such that $q_0=q_i$.
			A run of TBA is \emph{accepting} iff it contains infinitely many accepting transitions.

			Finally, we define the \emph{language} $L_A \in \Sigma^\omega$ recognized by the automaton A. An $\omega$-word $w \in \Sigma^\omega$ belongs to $L_A$ iff there exists an accepting run of $A$ over the word $w$. 
			
		\section{Generalized Büchi Automaton}
		A \emph{transition-based Generalized Büchi automaton} (TGBA) $A=(\Sigma, Q, q_i, \Delta, G)$ is a modified TBA, where $G \in 2^\Delta$ is set containing sets of accepting conditions. A run of TGBA is \emph{accepting} iff it contains infinitely many accepting transitions \emph{for each} subset of $G$. 
		
		\section{Slim GFM Büchi Automaton Construction}
			We define \emph{slim GFM\footnote{Good for Markov decision processes [+zdroj]} Büchi automaton} (slim automaton) through its construction which is based on breakpoint construction. 
			\paragraph{Construction}
			Let us fix Büchi Automaton $A=(\Sigma, Q, q_i, \Delta, \Gamma)$. We can write $\Delta$ as a function $\hat{\delta}: Q \times \Sigma \rightarrow 2^Q$ with
			$\hat{\delta}: (q, a) \rightarrow \{q' \in Q | (q, a, q') \in \Delta\}$,
			which can be lifted to sets, using the deterministic transition function $\delta: 2^Q \times \Sigma \rightarrow 2^Q$ with
			$\delta: (S, a) \rightarrow
			\bigcup_{q\in S} \hat{\delta}(q,a)$.
			
			We also define an operator, ndet, that translates deterministic transition functions
			$\delta: R \times \Sigma \rightarrow R$ to relations using
			
			ndet: $(R \times \Sigma \rightarrow R) \rightarrow 2^{(R \times \Sigma \rightarrow R)}$
			with
			$\delta \rightarrow \{(q,a,q')|q' \in \delta(\{q\},a)\}$.
			
			This is just an easy means to move back and forth between functions and relations,
			and helps one to visualize the maximal number of successors. We next define the variations of subset and breakpoint constructions that are used to define \cancel{limit deterministic??} \emph{semi-deterministic} GFM automata(semi-deterministic automata) - which we use in our evaluation for comparison - and the slim automata we construct.
			
			Let $3^Q :=\{(S,S')|S'\subset S \subseteq Q\}$ and
			$3^Q_+:=\{(S,S')|S'\subseteq S \subseteq Q\}$.
			We define the subset notation for the transitions and accepting transitions as $\delta_S,\gamma_S:2^Q \times \Sigma \rightarrow 2^Q$ with
			
			$\delta_S: (S,a)\rightarrow\{q'\in Q | \exists q \in S.(q,a,q') \in \Delta\}$ and
			
			$\gamma_S: (S,a)\rightarrow\{q'\in Q | \exists q \in S.(q,a,q') \in \Gamma\}$
			
			We define the raw breakpoint transition
			$\delta_R:3^Q \times \Sigma \rightarrow 3^Q_+$ as
			$((S, S'), a) \rightarrow(\delta_S(S, a), \delta(S',a)\cup \gamma_S(S, a))$.
			In this construction, we follow the set of reachable states (first set) and the states that are reachable while passing at least one of the accepting transitions (second set). To turn this into a breakpoint automaton, we reset the second set to the empty set when it equals the first; the transitions where we reset the second set are exactly the accepting ones. The breakpoint automaton $D = (\Sigma, 3^Q, (q_i, \emptyset), \delta_B, \gamma_B)$ is defined such that, when $\delta_R: ((S, S'), a) \rightarrow (R, R')$, then there are three cases:
			
			\begin{enumerate}
				\item if $R=\emptyset$, then $\delta_B((S,S'))$ is undefined (or, if a complete automation is preferred, maps to a rejecting sink),
				\item else, if $R \neq R'$, then $\delta_B((S,S'),a)\rightarrow(R, R')$ is a non-accepting transition,
				\item otherwise $\delta_B, \gamma_B: \delta_B((S,S'),a)\rightarrow(R, \emptyset)$ is an accepting transition.
			\end{enumerate}
		
			Finally, we define transitions $\Delta_{SB}\subseteq 2^Q \times \Sigma \times 3^Q$ that lead from a subset to a breakpoint construction, and $\gamma_{2,1}:3^Q \times \Sigma \rightarrow 3^Q$ that promote the second set of a breakpoint construction to the first set as follows. (?? probably a different text will be necessary here, following enumerate is WIP)
			
			\begin{enumerate}
				\item $\Delta_{SB}=\{(S, a, (S', \emptyset)) | \emptyset \neq S' \subseteq \delta_S(S, a)\}$ are non-accepting transitions,
				\item if $\delta_S(S',a) = \gamma_S(S, a) = \emptyset$, then $\gamma_{p}((S,S'), a)$ and $\gamma_{w}((S,S'), a)$ are undefined, and
				\item otherwise
				 $\gamma_{p}:((S,S'),a)\rightarrow(\delta_S(S',a)\cup\gamma_S(S, a),\emptyset)$ and $\gamma_{w}:((S,S'),a)\rightarrow(\delta_S(S',a),\emptyset)$ are accepting transitions.
			\end{enumerate}
		
			...? (I guess I could define semi-deterministic automaton, as it will be used in evaluation for comparison)
			\section{Slim Automaton}
			We present 2 of possible variants of slim automata:
			
			$S=(\Sigma, 3^Q, (q_i,\emptyset), ndet(\delta_B)\cup ndet(\delta_{p}),ndet(\delta_B)\cup ndet(\gamma_{p}))$ is slim. (proof in text with original definition)
			
			$W=(\Sigma, 3^Q, (q_i,\emptyset), ndet(\delta_B)\cup ndet(\delta_{w}),ndet(\delta_B)\cup ndet(\gamma_{w}))$ is weak slim. 
			
			(Jen takova poznamka... Dava vlastne \emph{weak slim} smysl? Pokud to chapu, tak tady v puvodnim clanku definuji \emph{slim} spis jako vlastnost, nez jako nazev.. Takze \emph{weak slim} co davam do seminatoru by stale mel byt \emph{slim}...)
			
			\section{Slim Automaton Construction Generalized to TGBA}
			We want to construct a slim automaton from TGBA $T=(\Sigma, Q, q_i, \Delta, G)$. One possibility is to \emph{degeneralize} $T$ and to use previously mentioned algorithm in section 2.3. Another way is to extend slim automaton construction to TGBA.
			\paragraph{extended slim construction}
			We need to make sure we go infinitely many times trough each accepting subset $g \in G$. To achieve this, we will go through each subset one by one, using original algorithm. We will keep track of levels in the names of states. Let $|G|$ be number of levels and $i \in N, i<|G|$ the current level. At each level, we look at $i$th subset of $G$. We use same steps as in classic bp construction, but on each accepting transition the new state will be leveled up to $(i+1)\%|G|$, otherwise the target state has the same level. Our new automaton simulates $T$, as it accepts a word iff it cycles through all levels.
			
			We can keep the core of previous construction and just to extend it.  Names of states will   for  If $zs$
			Let $3^Q_i :=\{(S,S',i)|S'\subset S \subseteq Q, i \in N, i<|G|\}$ and
			$3^Q_{i+}:=\{(S,S',i)|S'\subseteq S \subseteq Q, i \in N, i<|G|\}$.
			
			
		
	\chapter{To Delete Chapter}
		\section{Büchi Automaton}
		A nondeterministic Büchi automaton (BA) is a tuple 
		$A=(\Sigma, Q, q_0, \Delta, \Gamma)$,
		where
		\begin{itemize}
			\item $\Sigma$ is a finite alphabet
			\item $Q$ is finite set of states
			\item $q_0 \in Q$ is the initial state
			\item $\Delta \subseteq Q \times \Sigma \times Q$
			are transitions
			\item $\Gamma \subseteq \Delta$
			are accepting transitions
		\end{itemize} 
		\paragraph{run}
		A run $r$ of $A$ on $w \in \Sigma^\omega$
		is an $\omega$-word $r_0, w_0, r_1, w_1,...$ in $(Q\times\Sigma)^\omega$
		such that $r_0 = q_0 \land\forall i>0, (r_{i-1}, w_{i-1}, r_i) \in \Delta$ 
		\paragraph{inf(r)}
		We write $inf(r) \subseteq \Delta$ for the set of transitions that appear infinitely often in the run $r$.
		\paragraph{accepting run} A run $r$ is accepting if $inf(r) \cap \Gamma \neq \emptyset$
		\paragraph{language}
		The language $L_A\subseteq\Sigma^\omega$ is recognized by $A$.\newline
		$\forall w \in L_A \exists r$ on $w$ such that r is accepting.
		\paragraph{$\omega$-regular language}
		A language is $\omega$-regular if it is accepted by BA.
		\paragraph{deterministic automaton}
		$A=(\Sigma, Q, q_0, \Delta, \Gamma)$ is deterministic if \newline$(q, \rho, q^`), (q, \rho, q^{``})\in\Delta\implies q^`=q^{``}$
		\paragraph{complete automaton}
		$A$ is complete if, $\forall w \in \Sigma, \forall q \in Q, \exists (q, w, q^`)\in\Delta$. A word in $\Sigma^\omega$ has exactly one run in a deterministic, complete automaton. 
		
		nepouzivat $\rho$ , kombinace $\rho$ a q je spatna
		
		zminit v intro
		\section{Markov Decision Processes}
		A Markov decision process (MDP) $M$
		is a tuple $(S, A, T, \Sigma, L)$, where
		\begin{itemize}
			\item $S$ is a finite set of states
			\item $A$ is a finite set of actions
			\item $T:S\times A \rightarrow D(S)$, where $D(S)$ is set of probability distributions over S, is  the probabilistic transition (partial) function
			\item $\Sigma$ is an alphabet
			\item $L:S\times A \times S \rightarrow \Sigma$ is the labeling function of the set of transitions.
			For a state $s \in S, A(s)$ denotes the set of actions available in s.
		\end{itemize}
		\paragraph{run}
		A run of $M$ is an $\omega$-word 
		$s_0,a_1,...\in A=S \times (A \times S)^\omega$
		such that $Pr(s_{i+1}|s_i, a_{i+1})>0$ for all $i >= 0$. A finite run is a finite such sequence.
		\paragraph{labeled run}
		We define labeled run as
		$L(r)=L(s_0,a_1,s_1), L(s_1, a_2, s_2),... \in \Sigma^\omega$.
		\paragraph{paths}
		We write $\Omega(M)(Paths(M))$
		for the set of runs (finite runs) of $M$ and
		$\Omega_s(M)(Paths_s(M))$ for the set of runs (finite runs)
		of $M$ starting from state $s$. When the $MDP$ is clear from the context we drop the argument $M$.
		\paragraph{strategy}
		A strategy in $M$ is a
		function $\mu:Paths \rightarrow D(A)$
		such that $supp(\mu(r))\subseteq A(last(r))$,
		where $supp(d)$ is the support of $d$ and
		$last(r)$ is the last state of $r$.
		Let $\Omega^M_\mu$ denote the subset of runs $\Omega^M$
		that correspond to strategy $\mu$ and initial state $s$.
		Let $\Pi_M$ be the set of all strategies.
		\paragraph{pure strategy}
		We say that a strategy $\mu$ is pure
		if $\mu(r)$ is a point distribution for all runs $r \in Paths$.
		\paragraph{behavior}
		The behavior of an MDP $M$
		under a strategy $\mu$ with starting state $s$ is defined
		on a probability space $(\Omega_s^\mu, F_s^\mu, Pr_s^\mu)$
		over the set of infinite runs of $\mu$ from $s$.
		
		\section{[WIP]Good-for-MDP (GFM) Automata}
		Given an MDP $M$ and an
		automaton $A=(\Sigma, Q, q_0, \Delta, \Gamma)$, we want to compute an optimal strategy satisfying the objective that the run of $M$
		is in the language of A.
		\paragraph{semantic satisfaction probability for given automaton and strategy}
		We define the semantic satisfaction probability for $A$
		and strategy $\mu$ from state $s$ as:\newline
		$PSem_A^M(s,\mu)=Pr_s^\mu\{r \in\Omega_s^\mu:L(r)\in L_A  \}$
		\paragraph{semantic satisfaction probability for given automaton}
		.\newline
		$PSem_A^M(s)=\underset{\mu \in \Pi_M}{\sup} PSem_A^M(s, \mu)$
		\paragraph{syntactic variant of the acceptance condition}
		When using automata for given analysis of MDPs, we need
		a syntactic variant of the acceptance condition.
		\subparagraph{product of MDP and automaton}
		Given an MDP $M=(S,A,T,\Sigma,L)$ with initial state $s_0 \in S$
		and automaton $A = (\Sigma, Q, q_0, \Delta, \Gamma)$,
		the product $M \times A = (
		S \times Q,
		(s_0, q_0),
		A \times Q,
		T^\times,
		\Gamma^\times
		)$ is an MDP augmented with an inital state $s_0 \in S$ 
		and accepting transitions $\Gamma^\times$.
		The (partial) function
		$T^\times:
		(S \times Q) \times (A \times Q) \rightarrow D(S \times Q)$
		is defined by
		$T^\times((s,q), (a,q^`))((s^`, q^`))=
		\begin{cases}
			T(s,a)(s^`) &if (q,L(s,a,s^`),q^1) \in \Delta\\
			undefined &otherwise
		\end{cases}
		$
		\paragraph{GFM Automata}
		An automaton A is good for MDPs if, for all MDPs $M$, $PSYN_A^M(s_0) = PSEM_A^M(s_0)$ holds, where $s_0$ is the initial state of $M$.
		\section{to be defined}
		$\omega$-word?, point distribution?, what is $F_s^\mu$ in 'pure strategy' paragraph?, TGBA, describe Semi-determistic as I am going to compare them with SBA 
		\subsection{text}
		 
		
		GF MDP, model checking
		\section{Algorithms}
		BP + both slim 
	\chapter{Implementation}
		\section{Technologies}
		\section{Implementation inside Seminator}
	\chapter{Evaluation}
		\section{Alternative Algorithm}
		\section{Different Implementation - ePMC}
		\section{Semi-deterministic Automata}
	\chapter{Conclusion}
\end{document}