\documentclass[
	digital
nolof, nolot
]{fithesis3}

\usepackage{paratype}
\def\textrussian#1{{\usefont{T2A}{PTSerif-TLF}{m}{rm}#1}}

\thesissetup{
	date        = \the\year/\the\month/\the\day,
	university  = mu,
	faculty     = fi,
	type        = bc,
	author      = Pavel Šimovec,
	gender      = m,
	advisor     = {RNDr. František Blahoudek, Ph.D.; doc. RNDr. Jan Strejček, Ph.D.},
	title       = {Transformation of Nondeterministic Büchi Automata to Slim Automata},
	TeXtitle    = {Transformation of Nondeterministic Büchi Automata to Slim Automata},
	keywords    = {keyword1, keyword2, ...},
	TeXkeywords = {keyword1, keyword2, \ldots},
	abstract    = {%
		abstract
	},
	thanks      = {%
		ack
	},
	bib         = example.bib,
	%% Uncomment the following line (by removing the %% at the
	%% beginning) and replace `assignment.pdf` with the filename
	%% of your scanned thesis assignment.
	%%    assignment         = assignment.pdf,
}

%%\usepackage{amsmath}


\usepackage{makeidx}      %% The `makeidx` package contains
\makeindex                %% helper commands for index typesetting.
%% These additional packages are used within the document:
\usepackage{paralist} %% Compact list environments
\usepackage{amsmath}  %% Mathematics
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{url}      %% Hyperlinks
\usepackage{markdown} %% Lightweight markup
\usepackage{tabularx} %% Tables
\usepackage{tabu}
\usepackage{booktabs}
\usepackage{listings} %% Source code highlighting
\usepackage{emoji}
\usepackage{cancel}

\usepackage{listings}

\usepackage{tikz}
\usetikzlibrary{myautomata}
\input{commands.tex}

\lstset{
	basicstyle      = \ttfamily,
	identifierstyle = \color{black},
	keywordstyle    = \color{blue},
	keywordstyle    = {[2]\color{cyan}},
	keywordstyle    = {[3]\color{olive}},
	stringstyle     = \color{teal},
	commentstyle    = \itshape\color{magenta},
	breaklines      = true,
}
\usepackage{floatrow} %% Putting captions above tables
\floatsetup[table]{capposition=top}

%% Calligraphy
\newcommand{\cA}{\mathcal{A}}
\newcommand{\cD}{\mathcal{D}}
\newcommand{\cN}{\mathcal{N}}
\newcommand{\cS}{\mathcal{S}}
\newcommand{\cT}{\mathcal{T}}

\newcommand{\lA}{L(\cA)}
\newcommand{\lD}{L(\cD)}
\newcommand{\lS}{L(\cS)}

%\newcommand{\eqdef}{\overset{\mathrm{def}}{=\joinrel=}}
\newcommand{\eqdef}{\overset{def}{=}}

\newcommand{\flushed}{\text{\emoji{flushed}}}
\newcommand{\hell}{\text{\emoji{fire}}}
\newcommand{\heaven}{\text{\emoji{innocent}}}

\begin{document}
	\chapter{Introduction}
	Buchi automaton is a finite machine over infinite words. It has been a topic of research for almost 60 years.
	There were discovered various kinds of similar machines with different properties and use cases.
	<<Some cool guys>> have invented slim automata.
	Slim automata are specially constructed from Buchi automata. It is good for MDP [main source]. Scope of this thesis is to implement algorithm to transform a Buchi automaton to a slim automaton. Another goal is to extend the algorithm to accept Generalized Buchi automata. After our implementation of algorithm as specified in paper, different implementation from epmc was found. We can compare some properties of these algorithms and their products.
	
	... slim automata are specially constructed Büchi automata.
	\chapter{Preliminaries}
		In this chapter we define a Büchi automaton and its generalized version.
		Then we continue with breakpoint algorithm. It allows us to introduce slim automata by its construction, which builds on the breakpoint one. Finally we generalize slim automaton construction to work with generalized Büchi automata.
		
		We will need to know that on \emph{alphabet} is a set of letters, an \emph{$\omega$-word} $w \in \Sigma^\omega$ is an infinite sequence of letters, and a \emph{language} $L \subseteq \Sigma^\omega$ is a set of $\omega$-words.
		\section{Büchi Automaton}
			A Büchi automaton is a theoretical finite-state machine used to define $\omega$-languages. It decides which infinitely long words ($\omega$-words) belong to its language.
			
			A \emph{transition-based Büchi automaton (TBA)} is a tuple $\cA\eqdef(\Sigma, Q, q_i, \Delta, \Gamma)$, where 
			\begin{itemize}
				\item $\Sigma$ is a non-empty finite \emph{alphabet},
				\item $Q$ is a non-empty finite set of \emph{states},
				\item $q_i \in Q$ is the initial state of $\cA$.
				\item We write the set of \emph{transitions} as $\Delta \subseteq Q \times \Sigma \times Q$. Intuitivelly, a transition $(s, a, t)$  directionally connects the states $s$ and $t$ with the letter $a$.
				\item $\Gamma \subseteq \Delta$ is a set of \emph{accepting transitions}.
			\end{itemize}
			
			A \emph{run} $r$ of $\cA$ is an infinite sequence of transitions
			$r\eqdef t_0t_1\ldots\in\Delta^\omega$, where $t_i=(s_i, a_i,s_{i+1})$,
			 such that $q_0=q_i$.
			A run of $\cA$ is \emph{accepting} iff it contains infinitely many accepting transitions.

			Finally, we define the \emph{language} $\lA \subseteq \Sigma^\omega$ recognized by the automaton $\cA$. An $\omega$-word $w \in \Sigma^\omega$ belongs to $\lA$ iff there exists an accepting run of $\cA$ over the word $w$. 
			
			
		\section{Generalized Büchi Automaton}
		A \emph{transition-based Generalized Büchi automaton} (TGBA) is a tuple $\cA\eqdef(\Sigma, Q, q_i, \Delta, G)$, where $\emptyset \subseteq G \subseteq 2^\Delta$ contains sets of accepting conditions and the rest is defined as for TBA. A run of $\cA$ is \emph{accepting} iff it contains infinitely many accepting transitions \emph{for each} $\Gamma \in G$. TBA can be seen as a special case of TGBA with $|G|=1$
		
		\section{Breakpoint Automaton}
			We want to define \emph{slim GFM\footnote{Good for Markov decision processes [+zdroj]} Büchi automaton} (slim automaton) through its construction which is based on breakpoint construction. 
			\paragraph{Construction}
			Let us fix a Büchi Automaton $\cA\eqdef(\Sigma, Q, q_i, \Delta, \Gamma)$. 
			We want to construct a deterministic automaton $\cD$ such that $\lD\subseteq \lA$ 
			We denote $3^Q$ by the set $\{(S,S') \mid S'\subsetneq S \subseteq Q\}$ and
			$3^Q_+$ by $\{(S,S') \mid S'\subseteq S \subseteq Q\}$.
			We define the notation for the transitions and accepting transitions as $\delta,\gamma:2^Q \times \Sigma \rightarrow 2^Q$ with
			
			$\delta: (S,a)\eqdef\{q'\in Q \mid \exists q \in S.(q,a,q') \in \Delta\}$ and
			
			$\gamma: (S,a)\eqdef\{q'\in Q \mid \exists q \in S.(q,a,q') \in \Gamma\}$
			
			(? Let us note that $\delta$ and $\gamma$ are deterministic transitions.)
			
			We define the raw breakpoint transition
			$\rho_\Gamma \colon 3^Q \times \Sigma \rightarrow 3^Q_+$ as
			\[\rho_\Gamma((S, S'), a) \eqdef(\delta(S, a), \delta(S',a)\cup \gamma(S, a))\]
			We follow the set of reachable states (first set) and the states that are reachable while passing at least one of the accepting transitions (second set).
			The transitions of the breakpoint automaton $\cD$ follow $\rho$ with an exception: they reset the second set to the empty set when it equals the first; the resetting transitions are accepting.
			The breakpoint automaton $\cD \eqdef (\Sigma, 3^Q, (q_i, \emptyset), \delta_D, \gamma_D)$ is defined such that, when $\rho\colon ((S, S'), a) = (R, R')$, then there are three cases:
			
			\begin{enumerate}
				\item if $R=\emptyset$, then $\delta_B((S,S'))$ is undefined (or, if a complete automation is preferred, maps to a rejecting sink),
				\item else, if $R \neq R'$, then $\delta_B((S,S'),a)=(R, R')$ is a non-accepting transition,
				and $\gamma_d((S,S'),a)$ is undefined.
				\item otherwise $\delta_D((S,S')=\gamma_D((S,S'),a)=(R, \emptyset)$ is an accepting transition.
			\end{enumerate}
			
			Breakpoint automata decide subset of original language (example in Figure \ref{fig:bp:non-equivalent}). On the other hand, semi-deterministic automata decide superset of such language. We are going to define a few more transitions on top of breakpoint construction which allow us to construct slim automata that decide exactly the class of GFM languages.
		
			\begin{figure}[ht]
				\begin{center}
					\begin{tikzpicture}[automaton]
						\node[state,initial] (a) {0};
						\node[state,right of = a] (b) {1};
						\node[state,above of = a] (c) {2};
						
						\node[right = 2cm of b,state,initial, sd green] (bp-0) {$\{0\},\emptyset$};
						\node[state,right = 1cm of bp-0, sd green] (bp-12) {$\{1,2\}, \emptyset$};
						\node[state,above = 1cm of bp-12, sd green] (bp-12-1) {$\{1,2\}, \{2\}$};
						
						\path[->,auto ]
						(c) edge[loop above] pic[] {eacc=0} pic{l=$a$} (c)
						(a) edge[] node {$a$} (c)
						(a) edge[] node {$a$} (b)
						(b) edge[loop above] node {$a$} (b)
						;
						\path[->,auto ]			
						(bp-0) edge[] node {$a$} (bp-12)
						(bp-12) edge[] node {$a$} (bp-12-1)
						(bp-12-1) edge[loop above] node {$a$} (bp-12-1)
						;
					\end{tikzpicture}
				\end{center}
				\caption{Example of breakpoint automaton (right) non-equivalent with the original Buchi Automaton (left)}
				\label{fig:bp:non-equivalent}
			\end{figure}
			
			
			
			\section{Slim Automata Construction [separate chapter?]}\label{section:slim}
			Breakpoint automata constructed as presented in the previous section are not always equivalent to the input automaton.
			
			In this section we define transitions  $\gamma_w, \gamma_p:3^Q \times \Sigma \rightarrow 3^Q$ that promote the second set of a breakpoint construction to the first set as follows. 
			
			\begin{enumerate}
				\item if $\delta_S(S',a) = \gamma_S(S, a) = \emptyset$, then $\gamma_{p}((S,S'), a)$ and $\gamma_{w}((S,S'), a)$ are undefined, and
				\item otherwise
				$\gamma_{p}:((S,S'),a)=(\delta(S',a)\cup\gamma(S, a),\emptyset)$ and $\gamma_{w}:((S,S'),a)=(\delta(S',a),\emptyset)$
			\end{enumerate}
			
			
			$\cS\eqdef(\Sigma, 3^Q, (q_i,\emptyset), \Delta_S ,\Gamma_S)$ is slim, when
			$\Delta_S=\Delta_D \cup \Gamma_p$ is set of transitions generated by $\delta_D$ and $\gamma_p$, and
			$\Gamma_S=\Gamma_D \cup \Gamma_p$ is set of accepting transitions, that is generated by $\gamma_D$ and $\gamma_p$. $\lS = \lA$ (proof in text with original definition)
			
			Alternatively, similarly defined using $\gamma_w$ instead of $\gamma_{p}$, automaton $\mathcal{W}\eqdef(\Sigma, 3^Q, (q_i,\emptyset), \Delta_w, \Gamma_w)$ is slim a and $\lS=\lA$. (no proof yet)
			
			\begin{figure}[ht]
				\begin{center}
					\begin{tikzpicture}[automaton]
						\node[state,initial] (a) {\flushed};
						\node[state,right of = a] (b) {\hell};
						\node[state,above of = a] (c) {\heaven};
						
						\node[right = 2cm of b,state,initial, sd green] (bp-0) {$\{\flushed\},\emptyset$};
						\node[state,right = 1cm of bp-0, sd green] (bp-12) {$\{\hell,\heaven\}, \emptyset$};
						\node[state,above = 1cm of bp-12, sd green] (bp-12-1) {$\{\hell,\heaven\}, \{\heaven\}$};
						\node[state,above = 1cm of bp-0, sd red] (bp-2) {$\{\heaven\}, \emptyset$};
						\node[state,above = 1cm of bp-2, cstate, unreachable] (bp-2-2) {$\{\heaven\}, \{\heaven\}$};
						
						\path[->,auto ]
						(c) edge[loop above] pic[] {eacc=0} pic{l=$a$} (c)
						(a) edge[] node {$a$} (c)
						(a) edge[] node {$a$} (b)
						(b) edge[loop above] node {$a$} (b)
						;
						\path[->,auto ]			
						(bp-0) edge[] node {$a$} (bp-12)
						(bp-12) edge[] node {$a$} (bp-12-1)
						(bp-12-1) edge[loop above] node {$a$} (bp-12-1)
						(bp-12-1) edge[red] pic[] {eacc=0} pic{l=$a$} (bp-2)
						(bp-2) edge[loop above] pic[] {eacc=0} pic{l=$a$} (bp-2)
						(bp-2) edge[unreachable, bend left] node {$a$} (bp-2-2)
						;
					\end{tikzpicture}
				\end{center}
				\caption{Slim automaton (right) and the original Buchi Automaton from Figure \ref{fig:bp:non-equivalent}(left)}
				\label{fig:slim:equivalent}
			\end{figure}

			
			\section{Slim Automaton Construction Generalized to TGBA}
			We want to construct a slim automaton from TGBA $\cT\eqdef(\Sigma, Q, q_i, \Delta, G)$.
			One possibility is to \emph{degeneralize} $\cT$ and to use previously mentioned algorithm in section 2.3. Another way is to extend slim automaton construction to TGBA.
			\paragraph{extended slim construction}
			We need to make sure we go infinitely many times trough each accepting subset $g \in G$. To achieve this, we will go through each subset one by one, using original algorithm. We will keep track of $levels\eqdef\{0,1,\ldots,|G|-1\}$ in the names of states. Let $|G|$ be number of $levels$ and $i \in N, i<|G|$ the current level. At each level $i$, we look at $i$th subset of $G$. We use same steps as in classic breakpoint construction, but on each accepting transition the new state will be leveled up to $(i+1)\bmod|G|$, otherwise the target state has the same level. Our new automaton simulates $\cT$, as it accepts a word iff it cycles through all levels. If $|G|=0$, we return a trivially accepting automaton
			
			We can use the core of previous construction and just to extend it with levels. Let
			$up(x)\eqdef(x+1)\bmod|G|$ 
			%$3^Q_i :=\{(S,S',i)|S'\subset S \subseteq Q, i \in N, i<|G|\}$ and
			
			%$3^Q_{i+}:=\{(S,S',i)|S'\subseteq S \subseteq Q, i \in N, i<|G|\}$.
			
			$P := 3^Q \times levels$ (?nepotrebuju and $P_+ := 3^Q_+ \times levels$)
			
			%$\delta: (S,a)\rightarrow\{q'\in Q | \exists q \in S.(q,a,q') \in \Delta\}$ and
			
			%%$\gamma_{iS}: (S,a)\rightarrow\{q'\in Q | \exists q \in S.(q,a,q') \in G_i\}$
			We define $\gamma_i$ similarly like $\gamma$, we just use $\Gamma_i$ instead of $\Gamma$ and it allows us to easily define the raw generalized breakpoint transitions
			$\rho_{\Gamma_{i}}\colon$ similarly as $\rho_\Gamma$ using $\gamma_i$ instead of $\gamma$.
			
			The generalized breakpoint automaton $\cD=(\Sigma, 3^Q\times\cN, ({q_i},\emptyset, 0))$ is defined such that, when $\delta_R\colon((S, S', i), a) \rightarrow (R, R', j)$, then there are three cases:
			\begin{enumerate}
				\item if $R=\emptyset$ , then $\delta_B((S,S',i))$ is undefined,
				\item else, if $R \neq R'$, then $\delta_B\colon((S,S',i),a) = (R,R',i)$ is a non-accepting transition,
				\item otherwise $\delta_B, \gamma_B \colon \delta_B((S,S',i),a) = (R, \emptyset, up(i))$.
			\end{enumerate}
		
		
				$\gamma_{p}: P \times \Sigma \rightarrow P$
			\begin{enumerate}
				\item if $\delta(S',a)=\gamma_{i}(S, a)=\emptyset$, then $ \gamma_{p}((S,S',i),a)$ is undefined, and
				\item otherwise $\gamma_p \colon ((S,S',i),a) = (\delta(S',a)\cup \gamma_{i}(S, a), \emptyset, up(i))$.
			\end{enumerate}
			$\cS\eqdef(\Sigma, P, (q_i,\emptyset,0), \Delta_p,\Gamma_p))$ is slim, when $\Delta_p$ is set of transitions generated by $\delta_b$ and $\gamma_p$, and $\Gamma_p$ is set of accepting transitions, that is generated by $\gamma_b$ and $\gamma_p$.
			
						\begin{figure}[ht]
				\begin{center}
					\begin{tikzpicture}[automaton]
						\node[state,initial] (a) {A};
						\node[state,above of = a] (d) {D};
						
						\node[right = 2cm of a,state,initial, cd blue] (bp-a-0) {$\{A\},\emptyset,0$};
						\node[state,right = 1cm of bp-a-0, cd blue] (bp-d-0) {$\{D\}, \emptyset,0$};
						\node[above = 2cm of bp-a-0,state, cd orange] (bp-a-1) {$\{A\},\emptyset,1$};
						\node[state,above = 2cm of bp-d-0, cd orange] (bp-d-1) {$\{D\}, \emptyset,1$};
						
						\path[->,auto ]
						(a) edge[loop below] pic[] {eacc=0} pic{l=$a$} (a)
						(a) edge[bend left] node {$c$} (d)
						(d) edge[bend left] node {$c$} (a)
						(d) edge[loop above] pic[] {eacc=1} pic{l=$d$} (d)
						;
						\path[->,auto ]
						(bp-a-0) edge[bend left] node {$c$} (bp-d-0)
						(bp-d-0) edge[bend left] node {$c$} (bp-a-0)
						(bp-a-1) edge[bend left] node {$c$} (bp-d-1)
						(bp-d-1) edge[bend left] node {$c$} (bp-a-1)
						
						(bp-a-1) edge[loop above] node {$a$} (bp-a-1)
						(bp-d-0) edge[loop below] node {$d$} (bp-d-0)
						
						(bp-a-0) edge[bend left, blue]  pic[] {eacc=3} pic{l=$a$} (bp-a-1)
						(bp-d-1) edge[bend left, orange]  pic[] {eacc=3} pic{l=$d$} (bp-d-0)
						
						
						;
					\end{tikzpicture}
				\end{center}
				\caption{Slim automaton (right) and the original TGBA(left)}
				\label{fig:slim:gen}
			\end{figure}
			\begin{figure}[ht]
				\begin{center}
					\begin{tikzpicture}[automaton]
						\node[state,initial] (a) {A};
						\node[state,above of = a] (d) {D};
						
						\node[right = 2cm of a,state,initial, cd blue] (bp-a-0) {$\{A\},\emptyset,0$};
						\node[state,right = 1cm of bp-a-0, cd blue] (bp-d-0) {$\{D\}, \emptyset,0$};
						\node[state,right = 1cm of bp-d-0, cd blue] (bp-ad-0) {$\{A,D\}, \emptyset,0$};
						\node[state,right = 1cm of bp-ad-0, cd blue] (bp-ad-a-0) {$\{A,D\}, \{A\},0$};
						\node[above = 2cm of bp-a-0,state, cd orange] (bp-a-1) {$\{A\},\emptyset,1$};
						\node[state,above = 2cm of bp-d-0, cd orange] (bp-d-1) {$\{D\}, \emptyset,1$};
						\node[state,above = 2cm of bp-ad-0, cd orange] (bp-ad-1) {$\{A,D\}, \emptyset,1$};
						\node[state,above = 2cm of bp-ad-a-0, cd orange] (bp-ad-d-1) {$\{A,D\}, \{D\},1$};
						
						\path[->,auto ]
						(a) edge[loop below] pic[] {eacc=0} pic{l=$a$} (a)
						(a) edge[bend left] node {$c$} (d)
						(d) edge[loop right] node {$c$} (d)
						(d) edge[bend left] node {$c$} (a)
						(d) edge[loop above] pic[] {eacc=1} pic{l=$d$} (d)
						;
						\path[->,auto ]
						(bp-a-0) edge[bend right] node {$c$} (bp-d-0)
						(bp-d-0) edge[bend right] node {$c$} (bp-ad-0)
						(bp-a-1) edge[bend left] node {$c$} (bp-d-1)
						(bp-d-1) edge[bend left] node {$c$} (bp-ad-1)
						
						(bp-a-1) edge[loop above] node {$a$} (bp-a-1)
						(bp-d-0) edge[loop below] node {$d$} (bp-d-0)
						
						(bp-ad-d-1) edge[loop above] node {$a$} (bp-ad-d-1)
						(bp-ad-a-0) edge[loop below] node {$d$} (bp-ad-a-0)
						
						(bp-a-0) edge[blue]  pic[] {eacc=3} pic{l=$a$} (bp-a-1)
						(bp-ad-0) edge[ blue]  pic[] {eacc=3} pic{l=$a$} (bp-a-1)
						(bp-ad-a-0) edge[ blue]  pic[] {eacc=3} pic{l=$a$} (bp-a-1)
						(bp-d-1) edge[orange]  pic[] {eacc=3} pic{l=$d$} (bp-d-0)
						(bp-ad-1) edge[orange]  pic[] {eacc=3} pic{l=$d$} (bp-d-0)
						(bp-ad-d-1) edge[orange]  pic[] {eacc=3} pic{l=$d$} (bp-d-0)
						
						(bp-ad-0) edge[bend right] node {$a$} (bp-ad-a-0)
						(bp-ad-1) edge[bend left] node {$d$} (bp-ad-d-1)
						
						(bp-ad-0) edge[loop below] node {$c$} (bp-ad-0)
						(bp-ad-1) edge[loop above] node {$c$} (bp-ad-1)
						
						
						(bp-ad-d-1) edge[orange] pic[] {eacc=3} pic{l=$c$} (bp-ad-0)
						(bp-ad-a-0) edge[ blue] pic[] {eacc=3} pic{l=$c$} (bp-d-1)
						
						
						;
					\end{tikzpicture}
				\end{center}
				\caption{Slim automaton (right) and the original TGBA(left)}
				\label{fig:slim:gg}
			\end{figure}
			

			
	\chapter{Implementation}
		I have implemented the generalized construction of slim automata in both weak and strong version (2.4,2.5). I have also added option to create breakpoint automata (2.3).
		
		\section{Technologies/Tools}
		The implementation is inside seminator, which is implemented in C++17 builds on Spot library[24-mklokocka].
		\subsection{Seminator} [zdroj mklokocka thesis] 
		Seminator is a Linux command-line tool which can be run with the seminator command.
		
		The tool expects the input automaton in the Hanoi Omega-Automata(HOA) format [25-mklokocka] on the standard input stream, but it can also read the input automaton from a file.
		
		[EXAMPLE OF sDBA created by seminator?]
		
	\subsection{Spot}
			\paragraph{ltl2tgba}...
	\paragraph{autfilt}...
	\paragraph{ltlcross}...
		\section{Create Slim Automata Using Seminator}
		By default, seminator creates sDBA. To create a slim automaton we need to add -{}-slim option. 
		\paragraph{Options} By default, -{}-slim tries all reasonable combinations of options, optimizes the output and chooses an automaton with the smallest number of states.
		
		There are several options to specify how we construct the automata.
		
		For example \texttt{seminator -{}-slim -{}-strong -{}-optimizations=0 -{}-via-tgba} generates output according to algorithm in 2.5. (Using \texttt{-{}-via-tba} converts input to tba first) With automaton
		
		[TBA (or TGBA?) INPUT EXAMPLE]
		
		\begin{lstlisting}[language=bash]
$ cat automaton.hoa | ./seminator --slim --strong --via-tgba --optimalizations=0
		\end{lstlisting}
		
		we will get output
		
		[SLIM OUTPUT EXAMPLE]
		 
		
		-{}-slim to generate slim automata by, defaults to unoptimized, "strong" slim algorithm
		
		-{}-weak use "weak"-slim algorithm instead
		
		-{}-best try weak and strong, optimize outputs with spot and choose the one with smaller automaton [delete and use as default]
		
		(add -{}-strong to generate just automata just by strong slim algorithm)
		[not implemented yet] neither --weak nor --strong specified try both, optimize and choose smaller result
		
		-{}-via-tba transform input automaton to tba (2.1) first
		
		-{}-via-tgba does not modify input automaton to tba.
		
		neither -{}-via-tba nor -{}-via-tgba: try both options, choose smallest automaton
		
		postprocess optimalizations  should be used be as a default option, use an option to disable
		
		\paragraph{Example}
		Transform automaton.hoa to a slim automaton.
		\begin{lstlisting}[language=bash]
$ cat automaton.hoa | ./seminator --slim
		\end{lstlisting}
	\section{Implementation of Slim Automata inside Seminator}
	I have implemented the generalized slim construction and its options mentioned in previous section 3.2. Furthermore, I have added an option to create breakpoint automata.
	
	There already was basis for breakpoint construction in seminator, inside class \texttt{bp\_twa}.
	As we can see in sections 2.3 and 2.4, slim automata construction builds on breakpoint automata construction.
	
	That allows us to simply extend the \texttt{bp\_twa} class.
	We create class \texttt{slim} that inherits from \texttt{bp\_twa}.
	In the \texttt{slim} class we build breakpoint automaton using \texttt{compute\_successors} method.
	Then we extend the method by adding accepting transitions $\gamma_p$, respectively $\gamma_w$ according to section 2.4, whenever we receive \texttt{-{}-slim} option.
	
	Then we extend main function to recognize our desired CLI options.
	
	As seminator didn't offer a command line option to create a bp automaton, I have added one ,-{}-bp, for comparison.
	
	
	
	\section{Testing and Verification}
	Implemented tests are basic, only language equivalence is checked.
	ltlcross and ltl2tgba tools are used. The tests use random LTL formulas that were already generated, the LTL formulas are transformed into automata in HOA format by ltl2tgba.
	Then the tool ltlcross cross-compares the automaton with \emph{seminator -{}-slim} with all supported [not yet] additional parameters.
	
	Only \emph{seminator -{}-slim -{}-strong -{}-via-tba} (and with no optimalizations) is proved, as it follows construction from [main source] which is proved.
	
	
	\section{How to Install Seminator}
	(jeste nevim kde tuto sekci dat, jestli ma mit tento nazev, co vsechno tady bude treba dat... no a jeste ro pak upravim podle toho jak to bude odevzdane v zipu)
	
	To install the tool we need install spot and to run 
	
	\begin{lstlisting}[language=bash]
autoreconf -i && ./configure && make.
	\end{lstlisting}
	\section{Future of Implementation}
	Implementation:
	python bindings, optimizations of slim construction (especially from TGBA)
	
	
	
	tests/verification:
	There should be another kind of tests - to check if our slim automata simulate the input automata (so the GFM property is not broken)
	
	Subject of following research, that is out of scope of this thesis, could be to verify if spot optimizations do not break the simulation property. 
	
	\chapter{Evaluation}
	Evaluation part builds on seminator-evaluation. We compare amount of states of output automata.
	
	3x3 tabulka, 3 sloupec best of, pocty minimalnich automatu 2x2 tabulka.. 
	celkovy cas v tabulce 3x3
	\section{Seminator -{}-slim}
	In this section we compare automaton size generated by seminator -{}-slim.
	We compare weak against slim and via-tba against via-tgba.
	\begin{center}
		\begin{tabular}{ |c|c|c|c| } 
			\hline
			&weak&strong&best \\
			\hline
			via tba&617 | 9160 & 436 | 7725 & 431 | 7456 \\
			\hline
			via tgba&654 | 10317 & 474 | 8793 & 468 | 8434 \\ 
			\hline
			best&617 | 8968 & 436 | 7578 & 431 | 7275 \\ 
			\hline
		\end{tabular}
	\end{center}
	From 4 base options, strong slim algorithm via-tba creates smallest automata.
	Transforming input automata to tba first creates results which are close to best ones. 
	\section{Post-Optimized}

	
	
		\section{weak/strong}
		\subsection{Comparisons among Unoptimized options}
		\subsection{Comparisons among Post-Optimized options}
		
		\ref{section:slim}
		\section{via tba/no change}
		\subsection{Comparisons among Unoptimized options}
		\subsection{Comparisons among Post-Optimized options}
		(2.5)
		\section{Slim automata produced seminator ePMC}
		prvne tba zkusit pro epmc
		\section{Compare with semi-deterministic Automata}
		\section{To Put Somewhere in This Chapter}
		If the automata optimizations by spot's 
		\texttt{autfilt} tool break the simulation property, the results in following Evaluation chapter are pointless, as they are built on such assumption.
	\chapter{Conclusion}
\end{document}